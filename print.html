<!DOCTYPE HTML>
<html lang="pt" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Programação de Redes</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="cpp-asio/intro.html"><strong aria-hidden="true">1.</strong> Introdução</a></li><li class="chapter-item expanded "><a href="cpp-asio/concurrency.html"><strong aria-hidden="true">2.</strong> Concorrência  e Paralelismo</a></li><li class="chapter-item expanded "><a href="cpp-asio/install-asio.html"><strong aria-hidden="true">3.</strong> Instalação do Asio</a></li><li class="chapter-item expanded "><a href="cpp-asio/io_context.html"><strong aria-hidden="true">4.</strong> io_context</a></li><li class="chapter-item expanded "><a href="cpp-asio/buffer.html"><strong aria-hidden="true">5.</strong> Buffers</a></li><li class="chapter-item expanded "><a href="cpp-asio/executors.html"><strong aria-hidden="true">6.</strong> Executores</a></li><li class="chapter-item expanded "><a href="cpp-asio/socket.html"><strong aria-hidden="true">7.</strong> Sockets</a></li><li class="chapter-item expanded "><a href="cpp-asio/strand.html"><strong aria-hidden="true">8.</strong> Strands</a></li><li class="chapter-item expanded "><a href="cpp-asio/coroutine.html"><strong aria-hidden="true">9.</strong> Corrotinas</a></li><li class="chapter-item expanded "><a href="cpp-asio/endpoint.html"><strong aria-hidden="true">10.</strong> Endpoint</a></li><li class="chapter-item expanded "><a href="cpp-asio/dns-query.html"><strong aria-hidden="true">11.</strong> DNS</a></li><li class="chapter-item expanded "><a href="cpp-asio/throw-exception.html"><strong aria-hidden="true">12.</strong> Erros e exceções</a></li><li class="chapter-item expanded "><a href="cpp-asio/connect-server.html"><strong aria-hidden="true">13.</strong> Conectar ao Servidor</a></li><li class="chapter-item expanded "><a href="cpp-asio/accept-connections.html"><strong aria-hidden="true">14.</strong> Accept-Connections</a></li><li class="chapter-item expanded "><a href="cpp-asio/synchronous-read-write-operations.html"><strong aria-hidden="true">15.</strong> Operações síncronas</a></li><li class="chapter-item expanded "><a href="cpp-asio/asynchronous-read-write-operations.html"><strong aria-hidden="true">16.</strong> Operações assíncronas</a></li><li class="chapter-item expanded "><a href="cpp-asio/icmp-communication.html"><strong aria-hidden="true">17.</strong> Protocolo ICMP</a></li><li class="chapter-item expanded "><a href="cpp-asio/raw-communication.html"><strong aria-hidden="true">18.</strong> Protocolo RAW</a></li><li class="chapter-item expanded "><a href="cpp-asio/udp-communication.html"><strong aria-hidden="true">19.</strong> Protocolo UDP</a></li><li class="chapter-item expanded "><a href="cpp-asio/SSL-TLS.html"><strong aria-hidden="true">20.</strong> SSL/TLS</a></li><li class="chapter-item expanded "><a href="cpp-asio/serial.html"><strong aria-hidden="true">21.</strong> Serial</a></li><li class="chapter-item expanded "><a href="cpp-asio/some-examples.html"><strong aria-hidden="true">22.</strong> Exemplos</a></li><li class="chapter-item expanded "><a href="cpp-asio/the-end.html"><strong aria-hidden="true">23.</strong> Conclusão</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Programação de Redes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="programação-de-redes"><a class="header" href="#programação-de-redes">Programação de Redes</a></h1>
<h2 id="introdução"><a class="header" href="#introdução">Introdução:</a></h2>
<p>Inicialmente precisa conceituar o que é socket. A comunicação entre processos de software tornou-se indispensável nos sistemas atuais.</p>
<p>O elo entre os processos do servidor e do cliente é o socket. Ele é a “porta” na qual os processos enviam e recebem mensagens. De acordo com JAMES F KUROSE: “socket é a interface entre a <a href="https://pt.wikiversity.org/wiki/Introdu%C3%A7%C3%A3o_%C3%A0s_Redes_de_Computadores/Protocolos_de_aplica%C3%A7%C3%A3o_%E2%80%93_princ%C3%ADpios_gerais">camada de aplicação</a> e a <a href="https://pt.wikiversity.org/wiki/Introdu%C3%A7%C3%A3o_%C3%A0s_Redes_de_Computadores/Introdu%C3%A7%C3%A3o_%C3%A0_camada_de_transporte">camada de transporte</a> dentro de uma máquina”.</p>
<p>Então foram desenvolvidas diversas aplicações cliente/servidor onde cliente(s) e servidor poderiam estar em máquinas diferentes, distantes umas das outras. Os aplicativos do cliente e do servidor utilizam protocolos de transporte para se comunicarem. Quando um aplicativo interage com o software de protocolo, ele deve especificar detalhes, como por exemplo se é um servidor ou um cliente. Além disso, os aplicativos que se comunicam devem especificar detalhes adicionais (por exemplo, o remetente deve especificar os dados a serem enviados, e o receptor deve especificar onde os dados recebidos devem ser colocados).</p>
<p>Analisando o esquema acima percebemos que tudo acima da interface do socket, na camada de aplicação, é controlado pelo criador da aplicação. O controle da camada de transporte é feito pelo Sistema Operacional.</p>
<p>Temos dois tipos de serviços de transporte via socket: o confiável orientado a cadeia de bytes (byte steam) e os datagramas não confiáveis. O protocolo na qual é implementado o primeiro é o TCP, já o segundo é implementado no protocolo UDP. </p>
<h2 id="padrão-de-arquitetura-reactor-e-proactor-reativo-e-proativo"><a class="header" href="#padrão-de-arquitetura-reactor-e-proactor-reativo-e-proativo">Padrão de arquitetura Reactor e Proactor (Reativo e Proativo)</a></h2>
<h3 id="reactor"><a class="header" href="#reactor"><strong>Reactor</strong>:</a></h3>
<blockquote>
<p>&quot;Um padrão comportamental de objeto para desmultiplexação e distribuição de identificadores para eventos síncronos.&quot; - Douglas C. Schmidt</p>
</blockquote>
<p>O padrão de arquitetura do Reactor permite que aplicativos controlados por eventos desmultiplexem e despachem solicitações de serviço que são entregues a um aplicativo por um ou mais clientes. A estrutura introduzida pelo padrão do Reactor inverte o fluxo de controle dentro de um aplicativo.</p>
<p>É responsabilidade de um componente designado, chamado reactor, não um aplicativo, aguardar eventos de indicação de forma síncrona, desmultiplexá-los para manipuladores de eventos associados que são responsáveis pelo processamento desses eventos e, em seguida, despachar o método de gancho apropriado no manipulador de eventos. Em particular, um reactor despacha manipuladores de eventos que reagem à ocorrência de um evento específico. Portanto, os desenvolvedores de aplicativos são responsáveis apenas pela implementação de manipuladores de eventos concretos e podem reutilizar os mecanismos de desmultiplexação e despacho do reactor.
Embora o padrão do Reactor seja relativamente simples de programar e usar, ele possui várias restrições que podem limitar sua aplicabilidade. Em particular, ele não é dimensionado para suportar um grande número de clientes simultâneos e/ou solicitações de clientes de longa duração, pois serializa todo o processamento do manipulador de eventos na camada de desmultiplexação de eventos.</p>
<p>Para ilustrar o padrão do Reactor, considere o servidor acionado por eventos para um serviço de log distribuído mostrado na Figura abaixo. Os aplicativos clientes usam o serviço de log para registrar informações sobre seu status em um ambiente distribuído. Essas informações de status geralmente incluem notificações de erro, rastreamentos de depuração e relatórios de desempenho. Os registros de log são enviados para um servidor de log central, que pode gravar os registros em vários dispositivos de saída, como um console, uma impressora, um arquivo ou um banco de dados de gerenciamento de rede.</p>
<p>O servidor de log lida com registros de log e solicitações de conexão enviadas pelos clientes. Registros de log e solicitações de conexão podem chegar simultaneamente em vários identificadores. Um identificador identifica os recursos de comunicação de rede gerenciados em um SO.</p>
<p><img src="https://raw.githubusercontent.com/kassane/Livro-Programacao-de-Redes/gh-pages/images/reactor.jpg" alt="image" /> </p>
<p><strong>Figura 1: Serviço de Log Distribuído</strong></p>
<p>O servidor de log se comunica com os clientes usando um protocolo orientado a conexão, como o TCP. Os clientes que desejam registrar dados devem primeiro enviar uma solicitação de conexão ao servidor. O servidor aguarda essas solicitações de conexão usando um identificador de fábrica que escuta em um endereço conhecido pelos clientes. Quando uma solicitação de conexão chega, a fábrica de identificadores estabelece uma conexão entre o cliente e o servidor, criando um novo identificador que representa um ponto de extremidade da conexão. Esse identificador é retornado ao servidor, que aguarda as solicitações de serviço ao cliente chegarem no identificador. Depois que os clientes estão conectados, eles podem enviar registros simultaneamente ao servidor. O servidor recebe esses registros através dos identificadores de soquete conectados.</p>
<p>Talvez a maneira mais intuitiva de desenvolver um servidor de log simultâneo seja usar vários threads que possam processar vários clientes simultaneamente, como mostra abaixo. Essa abordagem aceita sincronicamente conexões de rede e gera um thread por conexão para manipular os registros de log do cliente.</p>
<p><img src="https://raw.githubusercontent.com/kassane/Livro-Programacao-de-Redes/gh-pages/images/reactor2.jpg" alt="image" /></p>
<p><strong>Figura 2: Servidor de log multithread</strong></p>
<p>No entanto, o uso de multithread para implementar o processamento de registros de log no servidor falha ao resolver as seguintes forças:</p>
<ul>
<li>Eficiência: a thread pode levar a um desempenho ruim devido à alternância de contexto, sincronização e movimentação de dados;</li>
<li>Simplicidade de programação: a thread pode exigir esquemas complexos de controle de simultaneidade;</li>
<li>Portabilidade: a thread não está disponível em todas as plataformas de SO.</li>
</ul>
<h3 id="proactor"><a class="header" href="#proactor"><strong>Proactor</strong>:</a></h3>
<blockquote>
<p>&quot;Um Padrão Comportamental de Objetos para desmultiplexar e despachar manipuladores para eventos assíncronos.&quot; - Douglas C. Schmidt</p>
</blockquote>
<p>O padrão de arquitetura Proactor permite que os aplicativos controlados por eventos desmultiplexem e despachem solicitações de serviços com eficiência, acionadas pela conclusão de operações assíncronas. Oferece os benefícios de desempenho da simultaneidade sem incorrer em alguns de seus passivos.</p>
<p>No padrão Proactor, os componentes do aplicativo são representados por clientes e manipuladores de conclusão que são entidades proativas. Diferentemente do padrão Reactor, que espera passivamente a chegada de eventos de indicação e reage, clientes e manipuladores de conclusão no padrão Proactor instigam o controle e o fluxo de dados dentro de um aplicativo iniciando uma ou mais solicitações de operação assíncrona proativamente em um processador de operação assíncrono.</p>
<p>Quando essas operações assíncronas são concluídas, o processador de operação assíncrona e um componente proactor designado colaboram para desmultiplexar os eventos de conclusão resultantes para seus manipuladores de conclusão associados e despachar os métodos de gancho desses manipuladores. Após o processamento de um evento de conclusão, um manipulador de conclusão pode iniciar novas solicitações de operação assíncrona de maneira proativa.</p>
<p>O padrão Proactor deve ser aplicado quando os aplicativos exigirem os benefícios de desempenho da execução simultânea de operações, sem as restrições síncrona ou reativa ou multithread. Para ilustrar esses benefícios, considere um aplicativo de rede que precise executar várias operações simultaneamente. Por exemplo, um servidor Web de alto desempenho deve processar simultaneamente solicitações HTTP enviadas de vários clientes. A Figura abaixo mostra uma interação típica entre navegadores Web e um servidor Web. Quando um usuário instrui um navegador a abrir uma URL, ele envia uma solicitação HTTP <code>GET</code> ao servidor da Web. Após o recebimento, o servidor analisa e valida a solicitação e envia os arquivos especificados de volta ao navegador.</p>
<p><img src="https://raw.githubusercontent.com/kassane/Livro-Programacao-de-Redes/gh-pages/images/proactor.jpg" alt="image" /></p>
<p><strong>Figura 3: Arquitetura típica de software de comunicação para servidor Web</strong></p>
<p>O desenvolvimento de servidores Web de alto desempenho requer a resolução das seguintes forças:</p>
<ul>
<li>Simultaneidade: O servidor deve executar várias solicitações do cliente simultaneamente;</li>
<li>Eficiência: O servidor deve minimizar a latência, maximizar a taxa de transferência e evitar a utilização desnecessária da CPU.</li>
<li>Simplicidade de programação: O design do servidor deve simplificar o uso de estratégias de concorrência eficientes;</li>
<li>Adaptabilidade: A integração de protocolos de transporte novos ou aprimorados (como <em>HTTP 1.1</em>) deve resultar em custos mínimos de manutenção.</li>
</ul>
<p>Um servidor Web pode ser implementado usando várias estratégias de simultaneidade, incluindo várias threads síncronos, envio de evento síncrono reativo e envio de evento assíncrono proativo. Abaixo, examinamos as desvantagens das abordagens convencionais e explicamos como o padrão Proactor fornece uma técnica poderosa que suporta uma estratégia eficiente e flexível de despacho de eventos assíncronos para aplicativos simultâneos de alto desempenho.</p>
<h3 id="acceptor-connector"><a class="header" href="#acceptor-connector"><strong>Acceptor-Connector</strong>:</a></h3>
<p>O padrão de projeto Acceptor-Connector desacopla a conexão e a inicialização dos serviços de ponto de cooperação em um sistema em rede do processamento que eles executam depois de conectados e inicializados. O Acceptor-Connector permite que os aplicativos configurem suas topologias de conexão de uma maneira amplamente independente dos serviços que eles fornecem. O padrão pode ser colocado em camadas na parte superior do Reactor para manipular eventos associados ao estabelecimento da conectividade entre serviços.</p>
<h3 id="reactor-vs-proactor"><a class="header" href="#reactor-vs-proactor"><strong>Reactor vs Proactor</strong>:</a></h3>
<p>Em geral, os mecanismos de multiplexação de E/S dependem de um desmultiplexador de eventos, um objeto que despacha eventos de E/S de um número limitado de fontes para os manipuladores de eventos de leitura e gravação apropriados. O desenvolvedor registra interesse em eventos específicos e fornece manipuladores de eventos ou retornos de chamada. O desmultiplexador de eventos entrega os eventos solicitados aos manipuladores de eventos.</p>
<p>Dois padrões que envolvem desmultiplexadores de eventos são chamados Reactor e Proactor. Os padrões do reactor envolvem E/S síncrona, enquanto o padrão Proactor envolve E/S assíncrona. No Reactor, o desmultiplexador de eventos aguarda os eventos que indicam quando um descritor ou socket de arquivo está pronto para uma operação de leitura ou gravação. O desmultiplexador passa esse evento para o manipulador apropriado, responsável por executar a leitura ou gravação real.</p>
<p>No padrão Proactor, por outro lado, o manipulador ou o desmultiplexador de eventos em nome do manipulador e inicia operações de leitura e gravação assíncronas. A própria operação de E/S é executada pelo sistema operacional (SO). Os parâmetros passados ​​para o sistema operacional incluem os endereços dos buffers de dados definidos pelo usuário, dos quais o sistema operacional obtém dados para gravação ou nos quais o sistema operacional coloca dados lidos. O desmultiplexador de eventos aguarda eventos que indicam a conclusão da operação de E/S e encaminha esses eventos para os manipuladores apropriados. Por exemplo, no Windows, um manipulador pode iniciar operações de E/S assíncronas (sobrepostas na terminologia da Microsoft), e o desmultiplexador de eventos pode esperar pelos eventos de IOCompletion. A implementação desse padrão assíncrono  é baseada em uma API assíncrona no nível do SO, e chamaremos essa implementação de assíncrona &quot;no nível do sistema&quot; ou &quot;true&quot;, porque o aplicativo depende totalmente do SO para executar a E/S real.</p>
<p>Um exemplo ajudará você a entender a diferença entre o Reactor e o Proactor. Vamos nos concentrar na operação de leitura aqui, pois a implementação de gravação é semelhante. Aqui está uma leitura no Reactor:</p>
<ul>
<li>Um manipulador de eventos declara interesse em eventos de E/S que indicam prontidão para leitura em um socket específico</li>
<li>O desmultiplexador de eventos aguarda eventos</li>
<li>Um evento chega e ativa o desmultiplexador e o desmultiplexador chama o manipulador apropriado</li>
<li>O manipulador de eventos executa a operação de leitura real, manipula a leitura de dados, declara interesse renovado em eventos de E/S e retorna o controle ao expedidor.</li>
</ul>
<p>Por comparação, aqui está uma operação de leitura no Proactor (true async):</p>
<ul>
<li>Um manipulador inicia uma operação de leitura assíncrona (nota: o sistema operacional deve suportar E/S assíncrona). Nesse caso, o manipulador não se importa com eventos de prontidão de E/S, mas, em vez disso, registra o interesse em receber eventos de conclusão.</li>
<li>O desmultiplexador de eventos aguarda até que a operação seja concluída</li>
<li>Enquanto o desmultiplexador de eventos aguarda, o SO executa a operação de leitura em um thread paralelo do kernel, coloca os dados em um buffer definido pelo usuário e notifica o desmultiplexador de eventos de que a leitura está concluída</li>
<li>O desmultiplexador de eventos chama o manipulador apropriado;</li>
<li>O manipulador de eventos manipula os dados do buffer definido pelo usuário, inicia uma nova operação assíncrona e retorna o controle ao desmultiplexador de eventos.</li>
</ul>
<p><em>Fonte:</em> <a href="http://www.dre.vanderbilt.edu/~schmidt/POSA/POSA2/">POSA2</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concorrência--paralelismo"><a class="header" href="#concorrência--paralelismo">Concorrência &amp; Paralelismo</a></h1>
<h2 id="threads"><a class="header" href="#threads">Threads:</a></h2>
<p>É um fluxo seqüencial de controle dentro de um programa. Basicamente, consiste em uma unidade básica de utilização da CPU, compreendendo um ID, um contador de programa, um conjunto de registradores e uma pilha. Um processo tradicional tem uma única thread de controle. Se o processo possui múltiplas threads de controle, ele pode realizar mais do que uma tarefa a cada momento. Essa possibilidade abre portas para um novo modelo de programação.</p>
<h3 id="green-threads"><a class="header" href="#green-threads">Green Threads:</a></h3>
<p>Green threads resolvem um problema comum na programação. Você não deseja que seu código bloqueie a CPU, impedindo que ela faça um trabalho significativo. Resolvemos isso usando multitarefa, o que nos permite suspender a execução de um pedaço de código enquanto retomamos outro e alternamos entre 'contextos'.</p>
<p>Isso não deve ser confundido com paralelismo, embora fácil confundir, são duas coisas diferentes. Pense dessa maneira: green threads nos permite trabalhar de maneira mais inteligente e eficiente e, assim, usar nossos recursos com mais eficiência, e o paralelismo é como jogar mais recursos no problema.</p>
<p>Geralmente, existem duas maneiras de fazer isso:</p>
<ul>
<li>Multitarefa preemptivo;</li>
<li>Multitarefa não preemptivo (ou multitarefa cooperativa).</li>
</ul>
<h2 id="multitasking-multitarefa"><a class="header" href="#multitasking-multitarefa">MultiTasking (MultiTarefa):</a></h2>
<p>É o processo de executar várias tarefas ao mesmo tempo em um único processador. Ele é usado para permitir que várias tarefas sejam executadas de forma simultânea e para aumentar a eficiência do processador. Existem várias técnicas de multitasking, como multitasking baseado em tempo, multitasking baseado em eventos e multitasking baseado em processos.</p>
<h3 id="tipos-de-tarefas"><a class="header" href="#tipos-de-tarefas">Tipos de tarefas:</a></h3>
<ul>
<li>
<p><strong>Preemptivo:</strong> Ocorre quando uma tarefa é interrompida por algum agendador externo e executa outra antes de voltar. A tarefa não tem nada a haver sobre esse assunto, a decisão é tomada pelo agendador. O kernel usa isso em sistemas operacionais, ou seja, para permitir que você use a interface do usuário enquanto executa a CPU para fazer cálculos em sistemas de thread único.</p>
</li>
<li>
<p><strong>Não-Preemptivo:</strong> Uma tarefa decide por si mesma quando é melhor a CPU fazer outra coisa do que esperar que algo aconteça na tarefa atual. Geralmente isso ocorre quando <code>yield</code> repassa o controle ao agendador. Um caso de uso normal para isso é gerar controle quando algo que irá bloquear a execução ocorre. Um exemplo disso são as operações de E/S. Quando o controle é gerado, um agendador central direciona a CPU para retomar o trabalho em outra tarefa que está pronta para realmente fazer outra coisa além de apenas bloquear.</p>
</li>
</ul>
<h2 id="síncrono-sync-e-assíncrono-async"><a class="header" href="#síncrono-sync-e-assíncrono-async">Síncrono (sync) e assíncrono (async):</a></h2>
<p>São dois termos que se referem ao modo como as operações são executadas em um programa de computador.</p>
<p><code>Sync</code>: são aquelas que são executadas de forma sequencial, ou seja, uma operação é executada após a conclusão da operação anterior. Isso significa que o programa é bloqueado enquanto a operação está sendo executada e não pode continuar até que a operação seja concluída.</p>
<p><code>Async</code>: são aquelas que são executadas de forma independente, ou seja, uma operação é iniciada e o programa continua a executar outras operações enquanto a operação assíncrona está sendo executada. Isso significa que o programa não é bloqueado enquanto a operação assíncrona está sendo executada e pode continuar a executar outras operações enquanto aguarda o término da operação assíncrona.</p>
<p>Operações síncronas são geralmente mais fáceis de programar e entender, mas podem ser menos eficientes em situações em que é necessário aguardar o término de uma operação para continuar a execução. Operações assíncronas, por outro lado, são geralmente mais eficientes, mas podem ser mais complexas de programar e entender.</p>
<h2 id="bloqueante-e-não-bloqueante"><a class="header" href="#bloqueante-e-não-bloqueante">Bloqueante e não-bloqueante:</a></h2>
<p>Blocking e non-blocking são termos que se referem ao modo como as operações são executadas em um programa de computador.</p>
<p>Operações blocking são aquelas que bloqueiam o programa enquanto aguardam o término de uma operação. Isso significa que o programa não pode continuar a executar outras operações enquanto aguarda o término da operação blocking.</p>
<p>Operações non-blocking, por outro lado, são aquelas que não bloqueiam o programa enquanto aguardam o término de uma operação. Isso significa que o programa pode continuar a executar outras operações enquanto aguarda o término da operação non-blocking.</p>
<p>Operações blocking são geralmente mais fáceis de programar e entender, mas podem ser menos eficientes em situações em que é necessário aguardar o término de uma operação para continuar a execução. Operações non-blocking, por outro lado, são geralmente mais eficientes, mas podem ser mais complexas de programar e entender.</p>
<h2 id="exclusão-mútua-mutex"><a class="header" href="#exclusão-mútua-mutex">Exclusão Mútua (Mutex)</a></h2>
<p><code>Mutex</code> (mutual exclusion, exclusão mútua em inglês): é um mecanismo de sincronização que é usado para garantir que apenas uma thread (rotina) de um programa de computador tenha acesso a uma região crítica de código por vez. Ele é usado para evitar conflitos de acesso entre threads que podem ocorrer quando várias threads tentam acessar e modificar o mesmo dado ao mesmo tempo. O mutex bloqueia a região crítica de código enquanto uma thread está acessando-a, garantindo que outras threads aguardem o término da operação antes de tentarem acessar a região crítica de código. </p>
<h2 id="epollkqueueiocpio_uring"><a class="header" href="#epollkqueueiocpio_uring">Epoll/Kqueue/IOCP/IO_uring:</a></h2>
<p>Epoll, Kqueue, IOCP e IO_uring são todos mecanismos de E/S event-driven (E/S com base em eventos) que são usados ​​para monitorar e gerenciar operações de entrada e saída assíncronas em sistemas operacionais diferentes. Eles são usados ​​para permitir que as aplicações sejam notificadas quando os dados estão disponíveis para leitura ou quando os dados podem ser escritos sem bloquear o processador.</p>
<p><code>Epoll</code>: é um mecanismo de E/S com base em eventos disponível no Linux. Ele permite que as aplicações monitorem vários descritores de arquivo para verificar se eles estão prontos para leitura ou escrita.</p>
<p><code>Kqueue</code>: é um mecanismo de E/S com base em eventos disponível no FreeBSD, NetBSD e OpenBSD. Ele funciona de maneira semelhante ao Epoll, permitindo que as aplicações monitorem descritores de arquivo para verificar se eles estão prontos para leitura ou escrita.</p>
<p><code>IOCP</code>: é um mecanismo de E/S com base em eventos disponível no Windows. Ele permite que as aplicações monitorem vários handles de arquivo e sockets para verificar se eles estão prontos para leitura ou escrita.</p>
<p><code>IO_uring</code>: é um mecanismo de E/S com base em eventos disponível no Linux. Ele foi projetado para ser mais rápido e eficiente do que o Epoll e oferece uma interface mais simples para as aplicações.</p>
<h2 id="coroutine-corrotina"><a class="header" href="#coroutine-corrotina">Coroutine (Corrotina):</a></h2>
<p>Na ciência da computação, as rotinas são definidas como uma sequência de operações. A execução de rotinas forma um relacionamento pai-filho e o filho termina sempre antes do pai. Corrotinas (o termo foi introduzido por <a href="https://en.wikipedia.org/wiki/Melvin_Conway">Melvin Conway</a>) são uma generalização de rotinas (<a href="https://en.wikipedia.org/wiki/Donald_Knuth">Donald Knuth</a>). A principal diferença entre corrotinas e rotinas é que uma corrotina permite suspender e retomar explicitamente seu progresso por meio de operações adicionais, preservando o estado de execução e, portanto, fornecendo um fluxo de controle aprimorado (mantendo o contexto de execução).</p>
<p>As características de uma corrotina são:</p>
<ul>
<li>Os valores dos dados locais persistem entre chamadas sucessivas (alternância de contexto);</li>
<li>A execução é suspensa quando o controle sai da rotina e é retomada em algum momento posterior;</li>
<li>Mecanismo de controle-transferência;</li>
<li>Simétrico ou assimétrico;</li>
<li>Objeto de primeira classe (pode ser passado como argumento, retornado por procedimentos, armazenado em uma estrutura de dados para ser usado posteriormente ou livremente manipulado pelo desenvolvedor);</li>
<li>Stackful (com pilha) ou Stackless (sem pilha).</li>
</ul>
<h3 id="stackfulness-com-pilha-ou-sem-pilha"><a class="header" href="#stackfulness-com-pilha-ou-sem-pilha"><strong>Stackfulness (com pilha ou sem pilha)</strong></a></h3>
<ul>
<li>
<p>Stackful (com pilha): pode ser suspensa de dentro de um stackframe (quadro de pilha) aninhado. A execução continua exatamente no mesmo ponto no código em que foi suspensa antes.</p>
</li>
<li>
<p>Stackless (sem pilha): apenas a rotina de nível superior pode ser suspensa. Qualquer rotina chamada por essa rotina de nível superior pode não ser suspensa. Isso proíbe o fornecimento de operações de suspensão ou retomada de rotinas dentro de uma biblioteca de uso geral.</p>
</li>
</ul>
<p>As coroutines stackless são implementadas sem usar uma pilha de chamadas de função, enquanto as coroutines stackful são implementadas com uma pilha de chamadas de função. As coroutines stackless são geralmente mais eficientes em termos de uso de memória, mas são mais difíceis de implementar e menos flexíveis do que as coroutines stackful.</p>
<h2 id="fiber-fibra"><a class="header" href="#fiber-fibra">Fiber (Fibra):</a></h2>
<p>Uma fibra pode salvar o estado de execução atual, incluindo todos os registradores e sinalizadores da CPU, o ponteiro de instruções e o ponteiro de pilha e, posteriormente, restaurar esse estado. A idéia é ter vários caminhos de execução em execução em uma única thread usando o planejamento cooperativo (ao contrario das threads, que são agendados preventivamente). A fibra em execução decide explicitamente quando deve permitir que outra fibra seja executada (alternância de contexto).</p>
<p>O controle é passado cooperativamente entre as fibras lançadas em um determinado segmento. Em um determinado momento, em um determinada thread, no máximo uma fibra está em execução.</p>
<p>A geração de fibras adicionais em um determinada thread não distribui seu programa por mais núcleos de hardware, embora possa fazer um uso mais eficaz do núcleo no qual está sendo executado.</p>
<p>Por outro lado, uma fibra pode acessar com segurança qualquer recurso pertencente exclusivamente a seu thread pai, sem precisar explicitamente defender esse recurso contra o acesso simultâneo de outras fibras na mesma thread. Você já está garantido que nenhuma outra fibra nessa thread está acessando simultaneamente neste mesmo recurso. Isso pode ser particularmente importante ao introduzir a concorrência no código legado. Você pode gerar fibras com segurança executando código antigo, usando E/S assíncrona para intercalar a execução.</p>
<p>Com efeito, as fibras fornecem uma maneira natural de organizar o código simultâneo com base em E/S assíncronas. Em vez de encadear manipuladores de conclusão, o código executado em uma fibra pode fazer o que parece ser uma chamada de função de bloqueio normal. Essa chamada pode suspender de forma barata a fibra de chamada, permitindo que outras fibras no mesma thread sejam executadas. Quando a operação é concluída, a fibra suspensa é retomada, sem a necessidade de salvar ou restaurar explicitamente seu estado. Suas variáveis ​​de pilha local persistem na chamada.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="instalando-asio"><a class="header" href="#instalando-asio">Instalando Asio</a></h1>
<p>Inicialmente existe duas versões disponíveis para download:</p>
<ul>
<li>
<p><a href="https://think-async.com/Asio">Asio Standalone</a> (sem boost) - <strong>Recomendação:</strong> C++11[<code>std::system_error</code>] ou posterior;</p>
</li>
<li>
<p><a href="https://www.boost.org">Boost Asio</a> (normalmente mais utilizado).</p>
</li>
<li>
<p><a href="https://timsong-cpp.github.io/cppwp/networking-ts/">Networking-TS</a> - Baseado no asio/boost::asio, proposto pela ISO para standard library <code>std::net</code>.</p>
</li>
</ul>
<p>Instalar Asio não é difícil. Pois ele possui apenas arquivos headers.</p>
<p>Os exemplos abaixo citarão a instalação do <code>boost::asio</code>.</p>
<h2 id="linux"><a class="header" href="#linux">Linux</a></h2>
<p><code>Ubuntu</code>:</p>
<pre><code>$ sudo apt-get install boost
</code></pre>
<p><code>Arch Linux</code>:</p>
<pre><code>$ sudo pacman -S boost
</code></pre>
<p>No linux para compilar um programa, o parâmetro <code>-pthread</code> se faz necessário:</p>
<pre><code>$ g++ client.cpp -o client -pthread -lboost_system
</code></pre>
<h2 id="bsd"><a class="header" href="#bsd">BSD</a></h2>
<p><code>OpenBSD</code>:</p>
<pre><code>$ pkg_add boost
</code></pre>
<p>Quando estiver compilando um programa, favor vincular as bibliotecas <code>boost</code>.</p>
<p>Ex.:</p>
<pre><code>$ c++ -L/usr/local/lib client.cpp -o client -lboost_system
</code></pre>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<p>Se você utiliza MSVC, então poderá optar por diversas opções:</p>
<ul>
<li>
<p>Baixar pré-compiladas: <a href="https://sourceforge.net/projects/boost/files/boost-binaries">Sourceforge</a></p>
</li>
<li>
<p>Usar <a href="https://github.com/microsoft/vcpkg"><code>vcpkg</code></a> com o seguinte parâmetro, ex.:</p>
<p>x86:</p>
<pre><code>  vcpkg install boost:x86-windows
</code></pre>
<p>ou</p>
<p>x64:</p>
<pre><code>  vcpkg install boost:x64-windows
</code></pre>
</li>
<li>
<p>Usar <a href="https://conan.io"><code>conan</code></a> (<strong>Requer:</strong> python) com o seguinte parâmetro, ex.:</p>
<p>Versão [1.72]:</p>
<pre><code>  conan install Boost/1.72.0@bincrafters/stable
</code></pre>
<p><strong>Nota:</strong> Para que a instalação com conan funcione neste repositório precisará utilizar este comando antes:</p>
<pre><code>  conan remote add bincrafters https://api.bintray.com/conan/bincrafters/public-conan
</code></pre>
<p>Para compilar no Windows usando MSVC no prompt de comando use:</p>
<pre><code>  cl /EHsc /I C:\Program Files\boost\boost_1_72_0 example.cpp /link /LIBPATH:C:\Program Files\boost\boost_1_72_0\lib
</code></pre>
</li>
</ul>
<p>Caso queira utilizar MinGW(Minimal GNU for Windows) terá duas opções:</p>
<ul>
<li>
<p><a href="http://www.msys2.org">MSYS2</a>:</p>
<p>x86:</p>
<pre><code>  $ pacman -S mingw-w64-i386-boost
</code></pre>
<p>x86_64:</p>
<pre><code>  $ pacman -S mingw-w64-x86_64-boost
</code></pre>
<p><strong>Nota:</strong> Por mais que parece ser um ambiente linux (minimalista), não requer uso do <code>sudo</code> na instalação</p>
</li>
<li>
<p>Compilar manualmente seguindo a documentação boost: <a href="https://www.boost.org/doc/libs/1_72_0/more/getting_started/windows.html">Windows - Getting Start</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asioio_context"><a class="header" href="#asioio_context"><code>asio::io_context</code></a></h1>
<p>O Asio possui uma classe chamada <code>asio::io_context</code> que é usada para gerenciar operações de entrada e saída assíncronas em um programa de computador. Ela é usada para monitorar e gerenciar operações de entrada e saída em vários descritores de arquivo e sockets, permitindo que o programa seja notificado quando os dados estão disponíveis para leitura ou quando os dados podem ser escritos sem bloquear o processador.</p>
<p>A <code>asio::io_context</code> é geralmente usada em conjunto com um objeto de work, que é responsável por manter o loop de eventos da <code>asio::io_context</code> rodando. O loop de eventos monitora os descritores de arquivo e sockets gerenciados pela <code>asio::io_context</code> e notifica o programa quando os dados estão disponíveis para leitura ou quando os dados podem ser escritos.</p>
<p>O conceito é baseado na API de rede do <code>Unix</code>, o <code>Asio</code> também possui o conceito &quot;socket&quot;, mas isso não é suficiente, um objeto <code>io_context</code> (a classe <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0112r0.html"><code>io_service</code></a> está obsoleta agora) é necessário para se comunicar com os serviços da E/S do sistema operacional. A  imagem abaixo mostrará a estrutura da Arquitetura <code>Asio</code>:</p>
<p><img src="https://raw.githubusercontent.com/kassane/Livro-Programacao-de-Redes/gh-pages/images/architecture.jpg" alt="image" /> </p>
<p><code>io_context</code> deriva de <code>execution_context</code>:</p>
<pre><code class="language-cpp">	class io_context
	  : public execution_context
	{
	......
	}
</code></pre>
<p>Enquanto <code>execution_context</code> deriva de <code>noncopyable</code>:</p>
<pre><code class="language-cpp">	class execution_context
	  : private noncopyable
	{
	......
	}
</code></pre>
<p>Observe a classe <code>noncopyable</code>:</p>
<pre><code class="language-cpp">	class noncopyable
	{
	protected:
	  noncopyable() {}
	  ~noncopyable() {}
	private:
	  noncopyable(const noncopyable&amp;);
	  const noncopyable&amp; operator=(const noncopyable&amp;);
	};
</code></pre>
<p>Isso significa que o objeto <code>io_context</code> não pode ser utilizado como <em>copy constructed/copy assignment/move constructed/move assignment</em>. Portanto, durante a inicialização do socket, ou seja, associar o socket ao<code> io_context</code>, o <code>io_context</code> deve ser passado como referência.</p>
<p>Ex.:</p>
<pre><code class="language-cpp">	template &lt;typename Protocol
	    BOOST_ASIO_SVC_TPARAM_DEF1(= datagram_socket_service&lt;Protocol&gt;)&gt;
	class basic_datagram_socket
	  : public basic_socket&lt;Protocol BOOST_ASIO_SVC_TARG&gt;
	{
	public:
	......
	  explicit basic_datagram_socket(boost::asio::io_context&amp; io_context)
	    : basic_socket&lt;Protocol BOOST_ASIO_SVC_TARG&gt;(io_context)
	  {
	  }
	......
	}
</code></pre>
<p>Além de gerenciar operações de entrada e saída assíncronas, a <code>asio::io_context</code> também fornece uma série de outras funcionalidades úteis. Por exemplo, ela permite que o programa agende operações para serem executadas em um momento futuro, permitindo que o programa execute tarefas de forma assíncrona de acordo com um cronograma. Ela também permite que o programa cancele operações que estão em andamento, permitindo que o programa interrompa tarefas que não são mais necessárias.</p>
<p>Outra funcionalidade útil da <code>asio::io_context</code> é a capacidade de escalonar operações em vários threads. Isso é útil em situações em que é necessário realizar várias operações de entrada e saída ao mesmo tempo e é importante aproveitar ao máximo o poder de processamento do computador. A <code>asio::io_context</code> pode ser configurada para escalonar operações em vários threads, permitindo que elas sejam executadas em paralelo e aproveitando ao máximo o poder de processamento do computador.</p>
<p>Em resumo, a <code>asio::io_context</code> é uma classe fundamental do Asio que é usada para gerenciar operações de entrada e saída assíncronas em um programa de computador. Ela monitora e gerencia descritores de arquivo e sockets, permitindo que o programa seja notificado quando os dados estão disponíveis para leitura ou quando os dados podem ser escritos sem bloquear o processador. Além disso, a <code>asio::io_context</code> fornece uma série de outras funcionalidades úteis, como agendamento de operações para serem executadas em um momento futuro, cancelamento de operações em andamento e escalonamento de operações em vários threads.</p>
<p>A seguir, estão descritas todas as funções comuns do <code>asio::io_context</code>:</p>
<ul>
<li>
<p><code>run</code>: A função run é usada para iniciar o loop de eventos do <code>asio::io_context</code>. Ela bloqueia o thread atual até que todas as operações agendadas tenham sido concluídas ou o <code>asio::io_context</code> seja interrompido.</p>
</li>
<li>
<p><code>poll</code>: A função poll é similar à função run, mas não bloqueia o thread atual. Em vez disso, ela processa todas as operações pendentes no <code>asio::io_context</code> e retorna imediatamente.</p>
</li>
<li>
<p><code>run_one</code>: A função run_one é similar à função run, mas processa apenas uma operação pendente no <code>asio::io_context</code> antes de retornar.</p>
</li>
<li>
<p><code>stop</code>: A função stop é usada para interromper o loop de eventos do <code>asio::io_context</code>. Isso é útil em situações em que o programa precisa sair do loop de eventos antes que todas as operações pendentes tenham sido concluídas.</p>
</li>
<li>
<p><code>reset</code>: A função reset é usada para reiniciar o <code>asio::io_context</code>. Isso é útil em situações em que o programa precisa começar a processar operações pendentes novamente após ter sido interrompido.</p>
</li>
<li>
<p><code>poll_one</code>: A função poll_one é similar à função poll, mas processa apenas uma operação pendente no asio::io_context antes de retornar.</p>
</li>
<li>
<p><code>poll_one_at</code>: A função poll_one_at é similar à função poll_one, mas retorna após o tempo especificado, mesmo se não houver operações pendentes para processar.</p>
</li>
<li>
<p><code>stopped</code>: A função stopped retorna true se o <code>asio::io_context</code> foi interrompido e false caso contrário.</p>
</li>
<li>
<p><code>get_executor</code>: A função get_executor retorna um objeto executor que pode ser usado para agendar operações para serem executadas no <code>asio::io_context</code>.</p>
</li>
<li>
<p><code>dispatch</code>: A função dispatch é usada para agendar uma operação para ser executada de forma síncrona no <code>asio::io_context</code>. Isso garante que a operação seja executada imediatamente, sem esperar por outras operações pendentes.</p>
</li>
<li>
<p><code>post</code>: A função post é usada para agendar uma operação para ser executada de forma assíncrona no <code>asio::io_context</code>. Isso permite que o programa continue rodando enquanto a operação é executada em segundo plano.</p>
</li>
<li>
<p><code>work</code>: Isso informa ao <code>asio::io_context</code> que há operações pendentes e garante que o loop de eventos continue rodando, mesmo quando não há operações pendentes.</p>
</li>
<li>
<p><code>work_guard</code>: A classe <code>asio::work_guard</code> é usada para gerenciar um objeto <code>asio::work</code> adicionado ao <code>asio::io_context</code>. Ela garante que o objeto <code>asio::work</code> não seja removido do <code>asio::io_context</code> enquanto o objeto asio::work_guard estiver em uso. Quando o objeto <code>asio::work_guard</code> é destruído, o objeto <code>asio::work</code> é removido do <code>asio::io_context</code> e o loop de eventos pode parar, se não houver mais operações pendentes para processar.
Além de gerenciar o objeto <code>asio::work</code>, <code>asio::work_guard</code> também fornece uma série de outras funcionalidades úteis. Por exemplo, é possível usar a função reset para adicionar um novo objeto <code>asio::work</code> ao <code>asio::io_context</code>, mesmo se o objeto asio::work_guard já estiver gerenciando um objeto <code>asio::work</code>. Além disso, é possível usar a função get_executor para obter um objeto executor que pode ser usado para agendar operações para serem executadas no <code>asio::io_context</code>.</p>
</li>
</ul>
<p>Em resumo, <code>asio::work_guard</code> é uma classe do Asio que é usada para gerenciar um objeto <code>asio::work</code> adicionado ao <code>asio::io_context</code>. Ela garante que o objeto <code>asio::work</code> não seja removido do <code>asio::io_context</code> enquanto o objeto <code>asio::work_guard</code> estiver em uso, garantindo assim que o loop de eventos continue rodando, mesmo quando não há operações pendentes para processar. Além disso, a <code>asio::work_guard</code> fornece uma série de outras funcionalidades úteis, como a possibilidade de adicionar um novo objeto <code>asio::work</code> ao <code>asio::io_context</code> e de obter um objeto executor para agendar operações para serem executadas no <code>asio::io_context</code>. <code>asio::work_guard</code> é especialmente útil em situações em que o programa precisa garantir que o asio::io_context continue rodando por um período prolongado de tempo, mesmo quando não há operações pendentes para processar. Isso é comum em programas que usam o Asio para implementar serviços de rede, como servidores web ou servidores de banco de dados.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="buffers"><a class="header" href="#buffers">Buffers</a></h1>
<p>Fundamentalmente, E/S envolve a transferência de dados para e de regiões contíguas da memória, chamadas buffers. Esses buffers podem ser simplesmente expressos como uma tupla que consiste em um ponteiro e um tamanho em bytes. No entanto, para permitir o desenvolvimento de aplicativos de rede eficientes, o <code>Asio</code> inclui suporte para operações de coleta de dispersão. Essas operações envolvem um ou mais buffers:</p>
<ul>
<li>Uma scatter-read recebe dados em vários buffers.</li>
<li>Uma gather-write transmite vários buffers.</li>
</ul>
<p>Portanto, exigimos uma abstração para representar uma coleção de buffers. A abordagem usada no <code>Asio</code> é definir um tipo (na verdade, dois tipos) para representar um único buffer. Eles podem ser armazenados em um contêiner, que pode ser passado para as operações de coleta de dispersão.</p>
<p>Além de especificar buffers como ponteiro e medir o tamanho em bytes, o <code>Asio</code> faz uma distinção entre memória modificável (mutável) e memória não modificável (onde a última é criada a partir do armazenamento para uma variável qualificada de const). Esses dois tipos podem, portanto, ser definidos da seguinte maneira:</p>
<pre><code class="language-cpp">    typedef std::pair&lt;void*, std::size_t&gt; mutable_buffer;
    typedef std::pair&lt;const void*, std::size_t&gt; const_buffer;
</code></pre>
<p>Um <code>mutable_buffer</code> seria conversível em um <code>const_buffer</code>, mas a conversão na direção oposta não é válida.</p>
<p>No entanto, o <code>Asio</code> não usa as definições acima como estão, mas define duas classes: <code>mutable_buffer</code> e <code>const_buffer</code>. O objetivo deles é fornecer uma representação opaca da memória contígua, onde:</p>
<ul>
<li>
<p>Os tipos se comportam como <code>std::pair</code> nas conversões. Ou seja, um <code>mutable_buffer</code> é conversível em um <code>const_buffer</code>, mas a conversão oposta é desabilitada.</p>
</li>
<li>
<p>There is protection against buffer overruns. Given a buffer instance, a user can only create another buffer representing the same range of memory or a sub-range of it. To provide further safety, the library also includes mechanisms for automatically determining the size of a buffer from an array, boost::array or std::vector of POD elements, or from a std::string.</p>
</li>
<li>
<p>A memória subjacente é acessada explicitamente usando a função membro <code>data()</code>. Em geral, um aplicativo nunca deve precisar fazer isso, mas é necessário que a implementação da biblioteca passe a memória não processada para as funções subjacentes do sistema operacional.</p>
</li>
</ul>
<p>Finalmente, vários buffers podem ser passados para operações (como <code>read()</code> ou <code>write()</code>) colocando os objetos do buffer em um contêiner. Os conceitos <code>MutableBufferSequence</code> e <code>ConstBufferSequence</code> foram definidos para que contêineres como <code>std::vector</code>, <code>std::list</code>, <code>std::array</code> ou <code>boost::array</code> possam ser usados.</p>
<h2 id="streambuf-para-integração-com-iostreams"><a class="header" href="#streambuf-para-integração-com-iostreams">Streambuf para integração com Iostreams</a></h2>
<p>A classe <code>boost::asio::basic_streambuf</code> é derivada de <code>std::basic_streambuf</code> para associar a sequência de entrada e a saída a um ou mais objetos de algum tipo de matriz de caracteres, cujos elementos armazenam valores arbitrários. Esses objetos da matriz de caracteres são internos ao objeto streambuf, mas é fornecido acesso direto aos elementos da matriz para permitir que sejam utilizados com operações de E/S, como as operações de envio ou recebimento de um socket:</p>
<ul>
<li>
<p>A sequência de entrada do streambuf é acessível através da função membro <code>data()</code>. O tipo de retorno dessa função atende aos requisitos <code>ConstBufferSequence</code>.</p>
</li>
<li>
<p>A sequência de saída do streambuf é acessível através da função membro <code>prepare()</code>. O tipo de retorno dessa função atende aos requisitos de <code>MutableBufferSequence</code>.</p>
</li>
<li>
<p>Os dados são transferidos sequência frontal de saída para a parte de trás da sequência de entrada chamando a função membro <code>commit()</code>.</p>
</li>
<li>
<p>Os dados são removidos da sequência frontal de entrada chamando a função de membro <code>consume()</code>.</p>
</li>
</ul>
<p>O construtor <code>streambuf</code> aceita um argumento <code>size_t</code> especificando a soma máximo dos tamanhos da sequência de entrada e de saída. Qualquer operação que, se for bem-sucedida, aumentará os dados internos além desse limite, lançará uma exceção <code>std::length_error</code>.</p>
<h2 id="tipos-de-buffers"><a class="header" href="#tipos-de-buffers">Tipos de Buffers</a></h2>
<p>O Asio fornece vários tipos de buffers que podem ser usados ​​para representar conjuntos de dados que podem ser lidos ou escritos de forma assíncrona. A seguir, uma lista de alguns dos tipos de buffers disponíveis no Asio:</p>
<ul>
<li>
<p><code>asio::const_buffer</code>: Representa um conjunto de dados que serão lidos, mas não alterados. Ele é útil quando você deseja ler os dados de uma fonte externa, como uma conexão de rede, sem alterá-los.</p>
</li>
<li>
<p><code>asio::mutable_buffer</code>: Representa um conjunto de dados que serão lidos e alterados. Ele é útil quando você deseja ler os dados de uma fonte externa e alterá-los antes de enviá-los para outro lugar.</p>
</li>
<li>
<p><code>asio::buffer</code>: É uma função que cria um buffer a partir de um objeto de tipo T. Ele pode ser usado para criar buffers a partir de qualquer tipo de dado, como strings, arrays ou estruturas de dados.</p>
</li>
<li>
<p><code>asio::buffer_cast</code>: É uma função que retorna um ponteiro para os dados subjacentes de um buffer. Ele é útil para acessar os dados de um buffer de forma mais conveniente.</p>
</li>
<li>
<p><code>asio::buffer_size</code>: É uma função que retorna o tamanho de um buffer em bytes. Ela é útil para determinar quantos dados podem ser lidos ou escritos em um buffer.</p>
</li>
</ul>
<p>Esses são apenas alguns dos tipos de buffers disponíveis no Asio. Existem outros tipos de buffers disponíveis para uso em situações específicas.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="o-que-é-um-executor"><a class="header" href="#o-que-é-um-executor">O que é um <code>Executor</code></a></h2>
<p>Um executor em C++ é um objeto ou mecanismo que é responsável por gerenciar o agendamento e a execução de tarefas ou operações em uma ou mais threads. Ele pode ser usado para gerenciar a concorrência e a sincronização entre as tarefas, garantindo que elas sejam executadas de forma eficiente e consistente.</p>
<p>Um executor em C++ pode ser implementado de várias maneiras diferentes, dependendo das necessidades da aplicação. Algumas possibilidades incluem:</p>
<ul>
<li>
<p>Usando <strong>threads</strong>: um executor pode ser implementado como um conjunto de threads que são responsáveis por executar as tarefas adicionadas a ele. Isso pode ser útil se a aplicação precisa de muitas tarefas sendo executadas concorrentemente e se houver recursos suficientes para suportar essas threads.</p>
</li>
<li>
<p>Usando um <strong>pool de threads</strong>: um executor pode ser implementado como um pool de threads que são compartilhados por todas as tarefas adicionadas a ele. Isso pode ajudar a gerenciar o uso de recursos, permitindo que mais tarefas sejam executadas concorrentemente, mas sem precisar criar novas threads para cada tarefa.</p>
</li>
<li>
<p>Usando um <strong>event loop</strong>: um executor pode ser implementado usando um event loop para gerenciar a execução de tarefas. Isso pode ser útil se a aplicação precisa lidar com múltiplos eventos simultâneos e se as tarefas só precisam ser executadas quando um evento ocorre.</p>
</li>
</ul>
<p>O event loop é uma estrutura de loop de execução que é usada para gerenciar a entrada e a saída de eventos em uma aplicação. Ele é comumente usado em aplicações que precisam lidar com múltiplos eventos simultâneos, como entrada do usuário, atualizações de redes ou operações de tempo de espera.
Em C++, um event loop pode ser implementado de várias maneiras diferentes, dependendo das necessidades da aplicação. Algumas possibilidades incluem:</p>
<ul>
<li>
<p>Usando um <strong>loop infinito</strong>: um event loop pode ser implementado como um loop infinito que verifica periodicamente por eventos. Isso pode ser útil se a aplicação precisa verificar por eventos com frequência, mas não precisa de uma resposta muito rápida.</p>
</li>
<li>
<p>Usando <strong>notificações assíncronas</strong>: um event loop pode ser implementado usando notificações assíncronas para ser avisado quando um evento ocorre. Isso pode ser útil se a aplicação precisa de uma resposta rápida aos eventos e se houver muitos eventos ocorrendo com pouco tempo de espera entre eles.</p>
</li>
</ul>
<p>Resumidamente, um executor pode ser usado em conjunto com um event loop para gerenciar a execução de tarefas que são disparadas por eventos. Por exemplo, se o event loop detecta um evento de entrada de usuário, ele pode adicionar uma tarefa ao executor para ser executada em uma thread separada, permitindo que a aplicação continue processando outros eventos enquanto a tarefa é executada. Isso pode ajudar a garantir que a aplicação responda de forma rápida e responsiva, mesmo quando há muitas tarefas a serem executadas.</p>
<h3 id="surgimento-do-assunto-em-torno-do-c-stl"><a class="header" href="#surgimento-do-assunto-em-torno-do-c-stl">Surgimento do assunto em torno do C++ STL</a></h3>
<p>Em 6 de julho de 2021, a proposta dos Executores foi atualizada com mais um bilhão de pontos. O novo documento, <a href="https://wg21.link/P2300">P2300</a>,
oficialmente denominado <code>std::execution</code>, em comparação com The Unified Executor for C++, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0443r14">P0443R14</a>,
expõe mais sistematicamente as ideias de design dos Executors; dá mais instruções sobre implementação.
A biblioteca Executors praticada pelo autor em seu tempo livre acaba de concluir o conteúdo do <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1897r3.html">P1879R3</a>.</p>
<p><code>Unified Executors</code> propõe que o namespace <code>std::execution</code> do C++ Standard Library que visa fornecer uma forma mais flexível e genérica de trabalhar com Executors. A proposta foi apresentada no Grupo de Trabalho 21 (WG21) do Comitê de Padrões do C++ como a Proposta de Padrão P1907R0.</p>
<p>Atualmente, o namespace <code>std::execution</code> fornece vários tipos de Executors, como <code>std::execution::sequenced_policy</code> e <code>std::execution::parallel_policy</code>, que podem ser usados ​​para controlar como as tarefas são agendadas e executadas. No entanto, esses Executors são bastante rígidos e não permitem muita flexibilidade na customização da forma como as tarefas são agendadas e executadas.</p>
<p>A proposta <code>Unified Executors</code> visa fornecer uma forma mais flexível de trabalhar com Executors, permitindo que os programadores criem seus próprios Executors personalizados de acordo com suas necessidades específicas. Isso seria feito através da introdução de novos tipos e funções no namespace <code>std::execution</code>, como <code>std::execution::uniform_invocable</code> e <code>std::execution::execute</code>, que permitiriam a criação de Executors personalizados de forma mais fácil e rápida.</p>
<p>A proposta de universal executors ainda está em fase de discussão no Grupo de Trabalho 21 (WG21) e ainda não foi adotada como parte do C++ Standard. No entanto, se aprovada, ela pode ser uma adição importante ao C++ Standard</p>
<h3 id="por-quê-executores"><a class="header" href="#por-quê-executores">Por quê Executores?</a></h3>
<p>C++ sempre careceu de infraestrutura de programação simultânea disponível, e a infraestrutura recém-introduzida desde C++11, bem como a melhoria de bibliotecas de terceiros, como boost e folly, têm mais ou menos problemas e certas limitações.</p>
<h3 id="stdasync-não-é-assíncrono"><a class="header" href="#stdasync-não-é-assíncrono"><code>std::async</code> não é assíncrono</a></h3>
<p><code>std::async</code> é uma função do C++ Standard Library que é usada para iniciar uma tarefa assíncrona em um ponto específico no tempo. Ela é usada para criar uma tarefa assíncrona que será executada em uma thread separada e retorna um objeto <code>std::future</code> que pode ser usado para obter o resultado da tarefa quando ela for concluída.</p>
<p>Apesar de seu nome, <code>std::async</code> não é uma função assíncrona no sentido tradicional da palavra. Ela não é capaz de retornar imediatamente para o chamador enquanto a tarefa assíncrona é executada, mas simplesmente inicia a tarefa em uma thread separada e retorna um objeto <code>std::future</code>. Isso significa que o código que chama <code>std::async</code> não pode ser escrito de forma assíncrona usando a sintaxe de await do C++20.</p>
<p>Apesar disso, <code>std::async</code> pode ser útil em situações em que é necessário iniciar uma tarefa assíncrona de forma fácil e rápida. Ele é especialmente útil quando é necessário obter o resultado da tarefa assíncrona de forma síncrona, usando a sintaxe de await do C++20 ou esperando pelo objeto <code>std::future</code> retornado por <code>std::async</code>.</p>
<p>A seguir, um exemplo de uso da função <code>std::async</code> para iniciar uma tarefa assíncrona e obter o resultado da tarefa de forma síncrona:</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;future&gt;

  // Função que será executada assincronamente
  int long_running_task(int x, int y) {
  // Simulando um processamento demorado
  std::this_thread::sleep_for(std::chrono::seconds(2));
  return x + y;
}

int main() {
  // Iniciando a tarefa assíncrona com std::async
  std::future&lt;int&gt; result = std::async(long_running_task, 10, 20);

  // Obtendo o resultado da tarefa síncronamente com std::future::get
  int sum = result.get();

  std::cout &lt;&lt; &quot;Resultado da tarefa assíncrona: &quot; &lt;&lt; sum &lt;&lt; std::endl;

  return 0;
}
</code></pre>
<p>Neste exemplo, a função long_running_task é iniciada de forma assíncrona com <code>std::async</code> e o resultado da tarefa é obtido síncronamente com <code>std::future::get</code>. Isso significa que o código que chama <code>std::async</code> será bloqueado até que a tarefa seja concluída e o resultado esteja disponível.</p>
<p>Observe que, apesar de usarmos <code>std::async</code> para iniciar a tarefa assíncrona, o código não pode ser escrito de forma assíncrona usando a sintaxe de await do C++20. Para escrever código assíncrono de forma mais simples e clara, é recomendável usar outras bibliotecas de tempo de execução, como Asio ou Libunifex.</p>
<p>Em resumo, <code>std::async</code> é uma função do C++ Standard Library que é usada para iniciar uma tarefa assíncrona em uma thread separada. Ela não é uma função assíncrona no sentido tradicional da palavra e não pode ser usada com a sintaxe de await do C++20, mas pode ser útil em situações em que é necessário iniciar uma tarefa assíncrona de forma fácil e rápida.</p>
<h3 id="modelo-de-evolução-do-futurepromise"><a class="header" href="#modelo-de-evolução-do-futurepromise">Modelo de Evolução do Future/Promise</a></h3>
<p>No C++11, o modelo future/promise é um meio de permitir que uma thread espere por um valor a ser produzido por outra thread de maneira assíncrona. Ele é composto pelos seguintes elementos:</p>
<ul>
<li>
<p><code>Promise</code>: um objeto que permite que um valor seja definido em algum momento no futuro. A promessa possui um método setValue para definir o valor e um método <code>setException</code> para definir uma exceção a ser lançada quando o valor for solicitado.</p>
</li>
<li>
<p><code>Future</code>: um objeto que permite que uma thread espere por um valor produzido por outra thread. O futuro possui um método wait que faz a thread que o chama esperar até que o valor esteja disponível. Além disso, o futuro possui métodos como <code>then</code> e <code>onError</code> que permitem que ações sejam executadas quando o valor estiver disponível ou uma exceção for lançada.</p>
</li>
</ul>
<p>A implementação de um Future/Promise típico em C++ é mostrada na figura abaixo:
<img src="https://user-images.githubusercontent.com/6756180/208737071-abe8d31c-fe0d-4023-8a1a-64083099c4f6.jpg" alt="img" /></p>
<p>Para usar o modelo de futuros e promessas, é preciso criar um objeto promessa e obter um objeto futuro a partir dele. Em seguida, a thread que produzirá o valor deve definir o valor na promessa usando o método <code>setValue</code> ou <code>setException</code>. A thread que estiver esperando pelo valor pode usar o método wait do futuro para esperar até que o valor esteja disponível.</p>
<p>Aqui está um exemplo de como usar o modelo de futuros e promessas em C++:</p>
<pre><code class="language-c++">#include &lt;future&gt;
#include &lt;iostream&gt;

int main() {
  // Cria uma promessa e um futuro
  std::promise&lt;int&gt; promise;
  std::future&lt;int&gt; future = promise.get_future();

  // Define o valor da promessa em uma thread separada
  std::thread([&amp;promise] {
    std::this_thread::sleep_for(std::chrono::seconds(1));
    promise.set_value(42);
  }).detach();

  // Espera pelo valor a ser definido e imprime-o
  std::cout &lt;&lt; future.get() &lt;&lt; std::endl;

  return 0;
}
</code></pre>
<p>Este código cria um objeto <code>std::promise</code> e um objeto <code>std::future</code>, e define o valor da <code>std::promise</code> em uma thread separada usando um <code>std::thread</code>. O objeto <code>std::future</code> é então usado para esperar pelo valor a ser definido, e o valor é impresso no console.</p>
<p>Essas classes são mais básicas do que as oferecidas pelas bibliotecas <code>folly</code> e <code>asio</code>, mas são parte da Biblioteca Padrão de C++ e, portanto, estão disponíveis em qualquer compilador C++ padrão.
As classes <code>std::future</code> e <code>std::promise</code> fornecem um conjunto similar de funcionalidades às classes <code>folly::Future</code> e <code>folly::Promise</code> da biblioteca <a href="https://github.com/facebook/folly">folly</a>, mas são parte da Biblioteca Padrão de C++ e não exigem dependências adicionais.</p>
<h3 id="executores-do-asio"><a class="header" href="#executores-do-asio">Executores do Asio</a></h3>
<p>Os executores são componentes do asio que definem o contexto de execução de uma função ou um bloco de código. Eles podem ser usados para controlar como e quando uma função ou um bloco de código é executado, e permitem que você aproveite os recursos de concorrência fornecidos pelo asio para executar tarefas de forma assíncrona e concorrente.</p>
<p>O asio fornece várias formas de se trabalhar com executores, incluindo a possibilidade de especificar o contexto de execução de uma função ou um bloco de código usando o template <code>asio::execution</code>, ou usando funções como <code>asio::post</code>, que permitem agendar a execução de uma função ou um bloco de código em um determinado contexto de execução.</p>
<p><code>asio::execution</code> é um modelo C++ que representa um contexto de execução, ou um objeto que define como uma função ou um bloco de código deve ser executado. É usado como um parâmetro de tipo em vários componentes asio, como <code>asio::strand</code> e <code>asio::spawn</code>, para especificar o contexto de execução no qual uma função ou um bloco de código deve ser executado.</p>
<p>Existem vários tipos de executores que podem ser usados com <code>asio::execution</code>. Estes incluem:</p>
<ul>
<li>
<p><code>asio::io_context::executor_type</code>: Este é o tipo de executor padrão para <code>asio::io_context</code> e representa o contexto de execução fornecido por um objeto <code>asio::io_context</code>. As funções ou blocos de código executados usando este executor serão executados no contexto do loop de eventos do io_context.</p>
</li>
<li>
<p><code>asio::strand&lt;Executor&gt;</code>: Este é um executor decorador que envolve outro executor, Executor, e garante que as funções ou blocos de código executados com ele sejam executados de forma serializada, ou seja, apenas um de cada vez. Isso pode ser útil para sincronizar o acesso a recursos compartilhados.</p>
</li>
<li>
<p><code>asio::system_executor</code>: Este é um tipo de executor especial que representa o contexto de execução fornecido pelo sistema operacional. As funções ou blocos de código executados usando este executor serão executados no contexto da thread pool do sistema operacional.</p>
</li>
<li>
<p><code>asio::thread_pool</code>: Este é um tipo de executor que representa um pool (grupo) de threads que podem serem usados para executar funções ou blocos de código, ou também para executar tarefas de forma concorrente em múltiplas threads.</p>
</li>
<li>
<p><code>asio::post</code>: Esta é uma função que leva uma função ou um bloco de código e um executor e agenda a função ou o bloco de código para ser executado no contexto do executor especificado.</p>
</li>
</ul>
<p>Em geral, <code>asio::execution</code> é um conceito poderoso que permite especificar o contexto de execução no qual uma função ou um bloco de código deve ser executado e aproveitar os vários tipos de executores fornecidos por asio para controlar a execução do seu código.</p>
<h3 id="asio-executores-em-comparação-com-outras-alternativas"><a class="header" href="#asio-executores-em-comparação-com-outras-alternativas">Asio executores em comparação com outras alternativas</a></h3>
<h4 id="stdexecution"><a class="header" href="#stdexecution"><code>std::execution</code></a></h4>
<p><code>std::execution</code> é um namespace do C++ Standard Library que fornece tipos e funções relacionados à execução de tarefas assíncronas. Ele foi introduzido no C++17 e ampliado no C++20 para fornecer uma interface padronizada para a execução de tarefas assíncronas em diferentes plataformas e bibliotecas de tempo de execução.</p>
<p>O conceito de Executor é uma parte importante do namespace <code>std::execution</code>. Ele é um tipo de modelo de classe que define uma interface para a execução de tarefas assíncronas. Um Executor é responsável por agendar tarefas para serem executadas em um determinado ponto no tempo, permitindo que o código assíncrono seja escrito de forma mais simples e clara.</p>
<p>O conceito de Executor é importante porque ele permite que você escreva código assíncrono de forma mais genérica, pois você pode usar a mesma interface para trabalhar com diferentes bibliotecas de tempo de execução sem precisar se preocupar com as diferenças entre elas. Isso torna o código mais portável e facilita a manutenção e a expansão do código no futuro.</p>
<p>O namespace <code>std::execution</code> fornece vários tipos de Executor, como <code>std::execution::sequenced_policy</code> e <code>std::execution::parallel_policy</code>, que podem ser usados ​​para controlar como as tarefas são agendadas e executadas. Além disso, ele fornece funções como <code>std::execution::execute</code> e <code>std::execution::bulk_execute</code>, que podem ser usadas para executar tarefas de forma assíncrona de acordo com o Executor especificado.</p>
<p>Em resumo, <code>std::execution</code> é um namespace do C++ Standard Library que fornece uma interface padronizada para a execução de tarefas assíncronas em diferentes plataformas e bibliotecas de tempo de execução, enquanto que Asio é uma biblioteca de tempo de execução que oferece recursos para criar aplicações de rede de forma assíncrona. Asio pode ser usado com o namespace <code>std::execution</code>, mas também pode ser usado de forma independente. A escolha da biblioteca a ser usada depende das necessidades específicas de sua aplicação e de suas preferências de programação.</p>
<h4 id="libunifex"><a class="header" href="#libunifex">Libunifex</a></h4>
<p><a href="https://github.com/facebookexperimental/libunifex">Libunifex</a> e Asio são duas bibliotecas diferentes que são utilizadas para criar aplicações de redes de forma assíncrona em C++.</p>
<p>ASIO é uma biblioteca de tempo de execução que oferece suporte para a comunicação assíncrona entre sistemas de computador. Ela é amplamente utilizada para a criação de aplicações de redes, como servidores de rede e clientes de rede. Asio fornece uma série de recursos, como sockets de rede, temporizadores e sinais de interrupção, que podem ser usados ​​para criar aplicações de rede de forma assíncrona.</p>
<p>Por outro lado, Libunifex é uma biblioteca de executores para C++ que oferece uma interface uniforme para a execução de tarefas assíncronas em diferentes plataformas e bibliotecas de tempo de execução, como Asio Standalone e Boost.ASIO. Ela permite que você escreva código assíncrono de forma mais portável, pois você pode usar a mesma interface para trabalhar com diferentes bibliotecas de tempo de execução sem precisar se preocupar com as diferenças entre elas.</p>
<h4 id="cppcoro"><a class="header" href="#cppcoro">Cppcoro</a></h4>
<p><a href="https://github.com/lewissbaker/cppcoro">Cppcoro</a> é uma alternativa a outras bibliotecas de tempo de execução para C++, como Asio e Libunifex, que também oferecem suporte para a programação assíncrona, porém com o uso de corrotinas ao invés de executores. Ela permite que você escreva código assíncrono de forma mais simples e clara, usando a sintaxe de corrotinas do C++20 STL.</p>
<p>Cppcoro usa a funcionalidade de coroutinas introduzida no C++20 para permitir que você escreva código assíncrono de forma mais fácil e natural. Ele fornece uma série de funções e tipos de dados que permitem que você crie, gerencie e execute coroutinas de forma mais eficiente. Além disso, ele fornece suporte para a execução de coroutinas em paralelo, o que pode ser útil em aplicações de alta performance.</p>
<p>Em resumo, Asio é uma biblioteca de tempo de execução que fornece recursos para criar aplicações de rede de forma assíncrona, enquanto que Libunifex é uma biblioteca de executores que oferece uma interface uniforme para trabalhar com diferentes bibliotecas de tempo de execução de forma mais portável.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sockets-soquetes"><a class="header" href="#sockets-soquetes">Sockets (Soquetes)</a></h1>
<p>A classe <code>asio::basic_stream_socket</code> do Asio é uma classe genérica que é usada como base para a criação de classes de socket específicas para diferentes protocolos de rede. Ela fornece uma interface comum para realizar operações de entrada e saída em sockets e é a classe base para a criação de classes de socket para protocolos como TCP, UDP, ICMP e SCTP.</p>
<p>A <code>asio::basic_stream_socket</code> fornece uma série de funções de leitura e escrita assíncronas que podem ser usadas para enviar e receber dados através de um socket de forma assíncrona. Ela também oferece funções para estabelecer conexões com outros hosts na rede e para fechar conexões existentes.</p>
<p>Para usar a <code>asio::basic_stream_socket</code>, é preciso criar uma classe derivada que especifique o tipo de socket que deseja criar, como um socket TCP, UDP, ICMP ou SCTP. Em seguida, é possível criar um objeto da classe derivada e passar um objeto de resolução de endereço e um objeto de io_context para o construtor. Em seguida, é possível chamar as funções de leitura e escrita fornecidas pela <code>asio::basic_stream_socket</code> para enviar e receber dados através do socket.</p>
<p>Existem <code>4</code> tipos de sockets:</p>
<p>(1) <code>basic_stream_socket</code>:<br />
Este socket fornece fluxos de bytes baseados em conexão bidirecional, confiável e sequencial. <code>tcp::socket</code> é uma instância deste socket:</p>
<pre><code class="language-cpp">	class tcp
	{
	......
	  /// The TCP socket type.
	  typedef basic_stream_socket&lt;tcp&gt; socket;
	......
	}
</code></pre>
<p>(2) <code>basic_datagram_socket</code>:<br />
Este socket fornece serviço de datagrama sem garantias de conexão e não confiável. <code>udp::socket</code> é uma instância deste socket:</p>
<pre><code class="language-cpp">	class udp
	{
	......
	  /// The UDP socket type.
  	  typedef basic_datagram_socket&lt;udp&gt; socket;
	......
	}
</code></pre>
<p>(3) <code>basic_raw_socket</code>:<br />
Este socket fornece acesso a protocolos e interfaces de rede interno. O <code>icmp::socket</code> é uma instância deste socket:</p>
<pre><code class="language-cpp">	class icmp
	{
	......
	  /// The ICMP socket type.
  	  typedef basic_raw_socket&lt;icmp&gt; socket;
	......
	}
</code></pre>
<p>(4) <code>basic_seq_packet_socket</code>:<br />
Este socket combina fluxo(stream) e datagrama: fornece um serviço de datagramas com conexão bidirecional, confiável e bidirecional. <a href="https://en.wikipedia.org/wiki/Stream_Control_Transmission_Protocol">SCTP</a> é um exemplo deste tipo de serviço.</p>
<p>Todos esses <code>4</code> sockets derivam da classe <code>basic_socket</code> e precisam ser associados a um <code>io_context</code> durante a inicialização. Veja <code>tcp::socket</code> como exemplo:</p>
<pre><code class="language-cpp">		boost::asio::io_context io_context;
		boost::asio::ip::tcp::socket socket{io_context};
</code></pre>
<p>Observe que o <code>io_context</code> deve ser uma referência no construtor do<code> socket</code> (consulte <a href="cpp-asio/cpp-asio/io_context.html">io_context</a>). Ainda use <code>basic_socket</code> e uma instância, um de seus construtores é o seguinte:</p>
<pre><code class="language-cpp">	  explicit basic_socket(boost::asio::io_context&amp; io_context)
	    : basic_io_object&lt;BOOST_ASIO_SVC_T&gt;(io_context)
	  {
	  }
</code></pre>
<p>Para a classe <code>basic_io_object</code>, ele não suporta copy constructed/copy assignment:</p>
<pre><code class="language-cpp">	......
	private:
	  basic_io_object(const basic_io_object&amp;);
	  void operator=(const basic_io_object&amp;);
	......
</code></pre>
<p>mas suporta move constructed/move assignment:</p>
<pre><code class="language-cpp">	......
	protected:  
	  basic_io_object(basic_io_object&amp;&amp; other)
	  {
	    ......
	  }
	  basic_io_object&amp; operator=(basic_io_object&amp;&amp; other)
	  {
	    ......
	  }
</code></pre>
<p>Além das funções de leitura e escrita assíncronas, a <code>asio::basic_stream_socket</code> também oferece uma série de outras funcionalidades úteis. Por exemplo, ela permite que o programa configure opções de socket, como o timeout de leitura e escrita, o tamanho do buffer de leitura e escrita e o uso de Keepalives. Ela também permite que o programa obtenha informações sobre o socket, como o endereço local e remoto, o estado da conexão e o número de bytes enviados e recebidos.</p>
<p>Em resumo, a asio::<code>basic_stream_socket</code> é uma classe genérica do Asio que é usada como base para a criação de classes de socket específicas para diferentes protocolos de rede. Ela fornece uma interface comum para realizar operações de entrada e saída em sockets e oferece uma série de funcionalidades úteis, como configuração de opções de socket e obtenção de informações sobre o socket.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strands-usar-threads-sem-bloqueio-explícito"><a class="header" href="#strands-usar-threads-sem-bloqueio-explícito"><code>Strands</code>: Usar threads sem bloqueio explícito</a></h1>
<p>A classe <code>asio::strand</code> é usada para garantir que operações de entrada e saída sejam executadas de forma serial em um objeto de io_context. Isso é útil em situações em que é importante que as operações de entrada e saída sejam realizadas em uma determinada ordem ou em que é importante evitar conflitos entre operações simultâneas.</p>
<p>Para usar a <code>asio::strand</code>, é preciso criar um objeto da classe e passar um objeto de io_context para o construtor. Em seguida, é possível chamar as funções de leitura e escrita assíncronas fornecidas pela <code>asio::strand</code> e passar um objeto de completion token para elas. Quando uma operação de entrada e saída é agendada através de uma <code>asio::strand</code>, ela é adicionada a uma fila de operações e é garantido que as operações na fila sejam executadas de forma serial.</p>
<p>Além de garantir que as operações de entrada e saída sejam executadas de forma serial, a <code>asio::strand</code> também fornece uma série de outras funcionalidades úteis. Por exemplo, ela permite que o programa cancele operações que estão em andamento e permite que o programa obtenha informações sobre o número de operações pendentes na fila.</p>
<p>Em resumo, <code>asio::strand</code> é usada para garantir que operações de entrada e saída sejam executadas de forma serial em um objeto de io_context. Ela oferece uma série de funcionalidades úteis, como cancelamento de operações em andamento e obtenção de informações sobre o número de operações pendentes na fila.</p>
<p>Uma thread é definida como uma chamada estritamente sequencial de manipuladores de eventos[event handler] (ou seja, nenhuma chamada simultânea). O uso de <code>asio::strand</code> permite a execução de código em um programa multithread sem a necessidade de bloqueio explícito (por exemplo, usando <code>mutex</code>[exclusão mútua]). E pode ser usado para sincronizar mais cenários.</p>
<p><code>Strand</code> agrupa tarefas. Tarefas do mesmo <code>asio::strand</code> não podem rodar em paralelo, mas quando suspensas, podem ser executadas em outra thread quando acordarem da próxima vez.</p>
<p>As <code>strands</code> podem ser implícitas ou explícitas, conforme ilustrado pelas seguintes abordagens alternativas:</p>
<ul>
<li>
<p>Utilizando <code>asio::io_context::run()</code> em apenas uma thread significa que todos os manipuladores de eventos são executados em uma thread implícita, devido à garantia do <code>asio::io_context</code> de que os manipuladores[handlers] são invocados somente de dentro da função <code>run()</code>.</p>
</li>
<li>
<p>Onde existe uma única cadeia de operações assíncronas associadas a uma conexão (por exemplo, em uma implementação de protocolo half-duplex como HTTP), não há possibilidade de execução simultânea dos manipuladores. Neste caso seria um <code>strand</code> implícito.</p>
</li>
<li>
<p>Um <code>strand</code> explícito é uma instância <code>strand&lt;&gt;</code> ou <code>asio::io_context::strand</code>. Todos os objetos de função do manipulador[handler] de eventos precisam ser vinculados ao strand usando <code>asio::bind_executor()</code> ou de outra forma postados/despachados através do objeto strand.</p>
</li>
</ul>
<p>Strand é genérico e pode ser usado para sincronizar mais cenários.</p>
<ul>
<li>
<p>Primeiro, que <code>defer()</code> só consegue enfileirar as tarefas de uma única cadeia de operações. Se você tem um canal duplex (ex.: <code>read()</code> e <code>write()</code> num único socket), então <code>defer()</code> já não oferece garantias o suficiente pra sincronizar o acesso aos dados compartilhados, e ainda tem que usar <code>strands</code>. Por esse motivo não posso fazer uso da otimização de <code>defer()</code> na lib de fibras, porque tem sempre um segundo canal assíncrono de notificações que representa a cadeia de cancelamento da fibra.</p>
</li>
<li>
<p>Segundo, <code>strands</code> podem ser usados no cenário onde há objetos trafegando entre múltiplos io_executors, mas <code>defer()</code> falha se você agenda, a partir de um contexto de execução, uma tarefa em outro contexto esperando que isso vá sincronizar/enfileirar/serializar algum trabalho.</p>
</li>
</ul>
<p>O executor associado deve atender aos requisitos do executor. Ele será usado pela operação assíncrona para enviar manipuladores intermediários e finais para execução.</p>
<p>O executor pode ser customizado para um tipo de manipulador específico, especificando um tipo aninhado <code>executor_type</code> e a função membro <code>get_executor()</code>.</p>
<p>Veja o exemplo abaixo:</p>
<pre><code class="language-cpp">    class my_handler
    {
    public:
    // Custom implementation of Executor type requirements.
    typedef my_executor executor_type;

    // Return a custom executor implementation.
    executor_type get_executor() const noexcept
    {
        return my_executor();
    }

    void operator()() { ... }
    };
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="corrotina"><a class="header" href="#corrotina">Corrotina</a></h1>
<p>Corrotinas são uma técnica de programação que permite que uma função seja dividida em várias partes, cada uma delas sendo executada de forma separada. Elas são usadas para criar funções assíncronas, ou seja, funções que podem ser &quot;pausadas&quot; e retomadas posteriormente, permitindo que o programa execute outras tarefas enquanto aguarda a conclusão de uma operação.</p>
<p>Por exemplo, suponha que você tenha uma função que faz uma chamada de rede para obter os dados de um determinado recurso. Usando corrotinas, você pode escrever essa função de forma síncrona, como se a chamada de rede fosse imediatamente concluída, e depois usar as corrotinas para &quot;pausar&quot; a execução da função enquanto aguarda a resposta da chamada de rede. Isso permite que o programa execute outras tarefas enquanto aguarda a resposta, em vez de ficar &quot;bloqueado&quot; aguardando a conclusão da chamada de rede.</p>
<h2 id="como-usar-corrotinas-no-c"><a class="header" href="#como-usar-corrotinas-no-c">Como usar corrotinas no C++</a></h2>
<p>No C++, existem duas maneiras de criar corrotinas: a primeira é usando a biblioteca Asio, e a segunda é usando o recurso <code>std::coroutine</code>, que foi adicionado ao C++20. As corrotinas <code>&lt;coroutine&gt;</code> são baseadas em uma nova sintaxe de linguagem do C++ e são mais fáceis de usar do que as corrotinas Asio, mas elas ainda são um recurso relativamente novo e podem não estar disponíveis em todas as implementações do C++.</p>
<p>Em resumo, as corrotinas Asio são uma maneira de criar e executar corrotinas no C++ usando a biblioteca Asio, enquanto as corrotinas <code>&lt;coroutine&gt;</code> são uma maneira de criar corrotinas usando uma nova sintaxe de linguagem adicionada ao C++20. Ambas as opções permitem que você crie funções assíncronas de forma fácil e eficiente.</p>
<p>Uma vantagem das corrotinas Asio é que elas podem ser usadas com qualquer biblioteca ou sistema que suporte a biblioteca Asio, o que significa que elas são compatíveis com uma ampla variedade de plataformas de rede. Além disso, as corrotinas Asio fornecem uma maneira de escrever código assíncrono de forma mais clara e legível, pois permitem que você escreva código síncrono que é &quot;convertido&quot; em código assíncrono pelo próprio Asio.</p>
<p>Por outro lado, as corrotinas são baseadas em uma nova sintaxe de linguagem e, por esse motivo, podem ser mais fáceis de usar do que as corrotinas Asio. Além disso, elas podem ser mais eficientes em termos de desempenho, pois elas são implementadas diretamente na linguagem C++ e não dependem de uma biblioteca externa. No entanto, elas ainda são um recurso relativamente novo e podem não estar disponíveis em todas as implementações do C++.</p>
<p>Em resumo, as corrotinas Asio e <code>std::coroutine</code> são duas maneiras diferentes de criar e executar corrotinas no C++. As corrotinas Asio são compatíveis com uma ampla variedade de plataformas e fornecem uma maneira de escrever código assíncrono de forma mais clara, enquanto as corrotinas <code>std::coroutine</code> são baseadas em uma nova sintaxe de linguagem e podem ser mais eficientes em termos de desempenho. Qual das duas opções é a melhor para você depende das suas necessidades e da plataforma em que está trabalhando.</p>
<p>A seguir, um exemplo de como usar corrotinas Asio para fazer uma chamada HTTP GET assíncrona usando a biblioteca Asio:</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;boost/asio/co_spawn.hpp&gt;
#include &lt;boost/asio/detached.hpp&gt;
#include &lt;boost/asio/io_context.hpp&gt;
#include &lt;boost/asio/ip/tcp.hpp&gt;

#include &lt;boost/beast/core.hpp&gt;
#include &lt;boost/beast/http.hpp&gt;
#include &lt;boost/beast/version.hpp&gt;
#include &lt;boost/asio/connect.hpp&gt;
#include &lt;boost/asio/ip/tcp.hpp&gt;
#include &lt;cstdlib&gt;

namespace beast = boost::beast;         // from &lt;boost/beast.hpp&gt;
namespace http = beast::http;           // from &lt;boost/beast/http.hpp&gt;
namespace net = boost::asio;            // from &lt;boost/asio.hpp&gt;
using tcp = net::ip::tcp;               // from &lt;boost/asio/ip/tcp.hpp&gt;

// Realiza uma chamada HTTP GET assíncrona e imprime o corpo da resposta
void async_http_get(net::io_context&amp; ioc, const std::string&amp; host, const std::string&amp; target)
{
    // Cria um socket TCP
    tcp::resolver resolver{ioc};
    beast::tcp_stream stream{ioc};

    // Realiza a resolução do nome do host e conecta ao servidor
    co_await resolver.async_resolve(host, &quot;http&quot;, net::use_awaitable);
    co_await stream.async_connect(resolver.results(), net::use_awaitable);

    // Cria uma solicitação HTTP e envia-a para o servidor
    http::request&lt;http::string_body&gt; req{http::verb::get, target, 11};
    req.set(http::field::host, host);
    req.set(http::field::user_agent, BOOST_BEAST_VERSION_STRING);
    co_await http::async_write(stream, req, net::use_awaitable);

    // Recebe a resposta do servidor
    beast::flat_buffer buffer;
    http::response&lt;http::string_body&gt; res;
    co_await http::async_read(stream, buffer, res, net::use_awaitable);

    // Imprime o corpo da resposta
    std::cout &lt;&lt; res &lt;&lt; std::endl;
}

int main()
{
    net::io_context ioc;

    // Inicia a chamada HTTP GET assíncrona em uma corrotina
    asio::co_spawn(ioc, [&amp;] {
        co_return async_http_get(ioc, &quot;www.example.com&quot;, &quot;/&quot;);
    }, asio::detached);

    // Executa o event loop
    ioc.run();

    return EXIT_SUCCESS;
}
</code></pre>
<p>Ao ter o primeiro contato com corrotinas em C++ (com asio) suponho que conhecerá novas palavras-chave que necessitará compreender, que são:</p>
<ul>
<li>
<p><code>co_spawn</code>: é uma função da biblioteca Asio que permite criar e iniciar uma corrotina de forma assíncrona. Ela é usada para &quot;lançar&quot; uma corrotina em uma determinada contexto de E/S, permitindo que a corrotina execute tarefas assíncronas como fazer chamadas de rede ou ler e escrever em arquivos.</p>
</li>
<li>
<p><code>co_yield</code>: é uma palavra-chave do C++ que permite que uma corrotina seja &quot;pausada&quot; e permita que outras corrotinas sejam executadas. Quando uma corrotina é &quot;pausada&quot; com <code>co_yield</code>, ela é suspensa temporariamente e permite que outras corrotinas sejam executadas. Quando outra corrotina termina sua execução, a corrotina &quot;pausada&quot; é retomada a partir do ponto onde foi interrompida.</p>
</li>
<li>
<p><code>co_await</code>: é uma palavra-chave do C++ que permite que uma corrotina aguarde a conclusão de uma operação assíncrona. Quando uma corrotina encontra um <code>co_await</code>, ela é &quot;pausada&quot; até que a operação assíncrona seja concluída, permitindo que outras corrotinas sejam executadas enquanto aguarda.</p>
</li>
<li>
<p><code>co_return</code>: é uma palavra-chave do C++ que permite que uma corrotina retorne um valor quando ela é concluída. É usado para encerrar a execução de uma corrotina e retornar o valor especificado para quem a chamou.</p>
</li>
<li>
<p><code>detached</code>: é um parâmetro opcional que pode ser usado com a função co_spawn da biblioteca Asio. Ele indica que a corrotina deve ser executada de forma assíncrona e não precisa ser aguardada para concluir sua execução. Isso é útil quando você deseja que a corrotina execute uma tarefa de forma independente e não precisa saber quando ela termina.</p>
</li>
</ul>
<p>As corrotinas Asio são uma extensão da biblioteca Asio que fornece suporte nativo para a criação e execução de corrotinas no C++. Elas permitem que você escreva código síncrono que é &quot;convertido&quot; em código assíncrono pelo próprio Asio, o que torna mais fácil criar funções assíncronas de forma clara e legível.</p>
<p>Para usar corrotinas Asio, você precisa incluir o cabeçalho <code>&lt;asio/co_spawn.hpp&gt;</code> e usar a palavra-chave co_await para &quot;pausar&quot; a execução da corrotina enquanto aguarda a conclusão de uma operação assíncrona. Você também pode usar a palavra-chave <code>co_yield</code> para &quot;pausar&quot; a execução da corrotina e permitir que outras corrotinas sejam executadas.</p>
<p>Além disso, as corrotinas Asio podem ser &quot;lançadas&quot; em um contexto de E/S usando a função <code>co_spawn</code>, que permite que a corrotina execute tarefas assíncronas como fazer chamadas de rede ou ler e escrever em arquivos. Você também pode usar a função <code>async_write</code> e <code>async_read</code> da biblioteca Asio para escrever e ler dados de forma assíncrona, respectivamente.</p>
<p>No entanto, é importante lembrar que as corrotinas Asio dependem da biblioteca Asio para funcionar, o que pode afetar o desempenho em comparação com outras opções, como as corrotinas <code>std::coroutine</code>, que são implementadas diretamente na linguagem C++. Qual das duas opções é a melhor para você depende das suas necessidades e da plataforma em que está trabalhando.</p>
<h4 id="completion-tokens"><a class="header" href="#completion-tokens">Completion Tokens</a></h4>
<p>Em Asio, um <a href="https://think-async.com/Asio/asio-1.24.0/doc/asio/overview/model/completion_tokens.html">completion token</a> é um tipo de dado usado para especificar como uma operação assíncrona deve ser completada. Ele é passado como um parâmetro para uma função assíncrona e é usado para determinar como a função deve notificar o chamador quando a operação for concluída.</p>
<p>Existem vários tipos de completion token disponíveis no Asio, como <code>asio::use_future</code> e <code>asio::use_awaitable</code>. Cada um desses tipos de completion token especifica uma forma diferente de completar a operação assíncrona.</p>
<p>Por exemplo, o completion token <code>asio::use_future</code> é usado para completar a operação assíncrona retornando um objeto <code>std::future</code> que pode ser usado para obter o resultado da operação. Isso permite que o chamador da função assíncrona aguarde o término da operação de forma síncrona, usando a sintaxe de await do C++20.</p>
<p>O completion token <code>asio::use_awaitable</code>, por outro lado, é usado para completar a operação assíncrona retornando um objeto awaitable que pode ser usado para aguardar o término da operação de forma assíncrona. Isso permite que o chamador da função assíncrona aguarde o término da operação de forma assíncrona, usando a sintaxe de await do C++20.</p>
<p>Em resumo, os completion tokens são usados ​​no Asio para especificar como uma operação assíncrona deve ser completada. Eles são passados como parâmetros para funções assíncronas e são usados ​​para determinar como a função deve notificar o chamador quando a operação for concluída. Existem vários tipos de completion token disponíveis, cada um com suas próprias características e usos específicos.</p>
<h3 id="asio-corrotina-comparado-com-cppcoro"><a class="header" href="#asio-corrotina-comparado-com-cppcoro">Asio Corrotina comparado com Cppcoro</a></h3>
<p>O cppcoro é uma biblioteca de corrotinas para C++ que fornece primitivas para escrever código assíncrono de maneira mais simples e legível. Ela foi projetada para funcionar em conjunto com o Asio, mas também pode ser usada com outras bibliotecas de E/S ou mesmo em aplicações sem E/S. A cppcoro utiliza o padrão de corrotinas do C++20 e é compatível com compiladores que já suportam esse padrão.</p>
<p>Ambas as bibliotecas permitem escrever código assíncrono de maneira mais simples, mas existem algumas diferenças entre elas:</p>
<ul>
<li>
<p>O Asio é uma biblioteca mais ampla que fornece suporte para várias plataformas, incluindo sistemas operacionais diferentes e dispositivos de E/S.
O Cppcoro, por outro lado, é focada apenas em corrotinas e foi projetado para ser usado como extensão do <code>std::coroutine</code>, mas também pode ser utilizado em conjunto com o Asio ou outras bibliotecas de E/S assíncronas (não obrigatório) ou  independentemente delas em aplicações sem E/S. Ele fornece uma série de primitivas para escrever código assíncrono de maneira mais simples e legível, como a palavra-chave <code>co_yield</code> para produzir um valor e suspender a execução da corrotina. Portanto, a cppcoro pode ser considerada mais completa e consistente no uso de corrotinas.</p>
</li>
<li>
<p>O Asio é mais amplamente usado em projetos em produção, enquanto que a Cppcoro é uma biblioteca mais nova e talvez menos conhecida. No entanto, ambas são opções válidas para escrever código assíncrono em C++.</p>
</li>
</ul>
<p>Ambos seguem como referêcia a proposta técnica <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1056r0.html">P1056R0</a> que descreve o progresso da especificação do suporte a corrotinas no C++, incluindo a sintaxe e as funções-membro para declarar e usar corrotinas, as palavras-chave <code>co_await</code> e <code>co_yield</code> para suspender e produzir valores na corrotina, e as classes <code>coroutine_handle</code> e <code>coroutine_traits</code> para gerenciar a execução de corrotinas. Ele também descreve o suporte a corrotinas em funções assíncronas, que permitem que corrotinas sejam usadas como uma alternativa ao modelo de callback functions para realizar operações assíncronas.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="endpoint-ponto-de-extremidade"><a class="header" href="#endpoint-ponto-de-extremidade">Endpoint (Ponto de Extremidade)</a></h1>
<p>O Asio fornece outros tipos de objetos endpoint para representar pontos finais de conexões de rede de outros protocolos, além do TCP. Por exemplo, o objeto <code>asio::ip::udp::endpoint</code> é usado para representar um ponto final de uma conexão de rede UDP. Ele é composto por um endereço IP e uma porta, e funciona de maneira similar ao objeto <code>asio::ip::tcp::endpoint</code>, mas é usado para protocolos UDP em vez de TCP.</p>
<p>O objeto <code>asio::ip::tcp::endpoint</code> é usado para representar um ponto final de uma conexão de rede TCP. Ele é composto por um endereço IP e uma porta, que são usados para identificar o host remoto ou o servidor que o programa deseja se conectar ou se comunicar.</p>
<p>Para usar o objeto <code>asio::ip::tcp::endpoint</code>, é preciso incluir o cabeçalho <code>&lt;boost/asio/ip/tcp.hpp&gt;</code> no seu código e criar um objeto da classe passando um endereço IP e uma porta para o construtor. Em seguida, é possível usar o objeto <code>asio::ip::tcp::endpoint</code> para identificar o host remoto ou o servidor que o programa deseja se conectar ou se comunicar.</p>
<p>O objeto <code>asio::ip::tcp::endpoint</code> também fornece uma série de outras funcionalidades úteis. Por exemplo, é possível usar as funções address e port para obter o endereço IP e a porta do objeto, respectivamente. Além disso, é possível usar a função <code>to_string</code> para obter uma string que representa o objeto <code>asio::ip::tcp::endpoint</code>.</p>
<p>Além disso, o Asio fornece outros tipos de objetos endpoint para representar pontos finais de conexões de outros protocolos, como o objeto <code>asio::ip::icmp::endpoint</code> para o protocolo ICMP e o objeto <code>asio::local::stream_protocol::endpoint</code> para o protocolo Unix local. Cada um desses objetos endpoint é composto por um endereço e uma porta, e fornece uma série de funcionalidades úteis para trabalhar com os respectivos protocolos de rede.</p>
<pre><code class="language-cpp">	basic_endpoint(const boost::asio::ip::address&amp; addr, unsigned short port_num)
	    : impl_(addr, port_num)
	{
		//TODO
	}
</code></pre>
<p>O cliente usa o <code>endpoint</code> para designar o endereço do servidor, e o aplicativo do servidor usa o <code>endpoint</code> para identificar qual endereço será usado para escutar e aceitar conexões. Um exemplo de <a href="https://pt.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a> <code>endpoint</code> abaixo:</p>
<pre><code class="language-cpp">	boost::asio::ip::tcp::endpoint endpoint{
		boost::asio::ip::make_address(&quot;127.0.0.1&quot;), 3303};
</code></pre>
<p>Normalmente, o servidor precisa escutar(listen) todos os endereços da máquina atual e pode recorrer a outro construtor de <code>basic_endpoint</code>:</p>
<pre><code class="language-cpp">	basic_endpoint(const InternetProtocol&amp; internet_protocol,
	      unsigned short port_num)
	    : impl_(internet_protocol.family(), port_num)
	{
	}
</code></pre>
<p>Um exemplo de servidor <a href="https://pt.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a> que escuta todos os endereços <code>IPv4</code> &amp; <code>IPv6</code>:</p>
<pre><code class="language-cpp">	//IPv6
	boost::asio::ip::udp::endpoint endpoint{
            boost::asio::ip::udp::v6(),
            3303};
	...
	//IPv4
	boost::asio::ip::udp::endpoint endpoint{
            boost::asio::ip::udp::v4(),
            3306};
</code></pre>
<p>Em resumo, o Asio fornece uma série de objetos endpoint para representar pontos finais de conexões de rede de diferentes protocolos. Cada um desses objetos endpoint é composto por um endereço e uma porta, e fornece uma série de funcionalidades úteis para trabalhar com os respectivos protocolos de rede.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dns-query"><a class="header" href="#dns-query">DNS Query</a></h1>
<p>O objeto <code>asio::ip::tcp::resolver</code> é usado para resolver nomes de domínio em endereços IP. Ele é útil em situações em que o programa precisa se conectar a um host remoto ou a um servidor usando um nome de domínio, mas precisa do endereço IP para estabelecer a conexão de rede.</p>
<p>Para usar o objeto <code>asio::ip::tcp::resolver</code>, é preciso incluir o cabeçalho <code>&lt;asio/ip/tcp.hpp&gt;</code> no seu código e criar um objeto da classe passando um objeto <code>asio::io_context</code> para o construtor. Em seguida, é possível usar o método resolve para resolver o nome de domínio em um endereço IP. O método resolve retorna um iterador que pode ser usado para percorrer a lista de endereços IP retornados.</p>
<p>O objeto <code>asio::ip::tcp::resolver</code> também fornece uma série de outras funcionalidades úteis. Por exemplo, é possível usar o método async_resolve para resolver o nome de domínio de forma assíncrona, permitindo que o programa continue rodando enquanto a resolução é realizada em segundo plano. Além disso, é possível usar o método cancel para cancelar a resolução de um nome de domínio em andamento.</p>
<p>Veja <code>boost::asio::ip::tcp::resolver</code> no exemplo abaixo:</p>
<pre><code class="language-cpp">
	#include &lt;boost/asio.hpp&gt;
	#include &lt;iostream&gt;
	
	int main()
	{
	    try
	    {
	        boost::asio::io_context io_context;
	
	        boost::asio::ip::tcp::resolver resolver{io_context};
	        boost::asio::ip::tcp::resolver::results_type endpoints =
	                resolver.resolve(&quot;google.com&quot;, &quot;https&quot;);
	
	        for (auto it = endpoints.cbegin(); it != endpoints.cend(); it++)
	        {
	            boost::asio::ip::tcp::endpoint endpoint = *it;
	            std::cout &lt;&lt; endpoint &lt;&lt; '\n';
	        }
	    }
	    catch (std::exception&amp; e)
	    {
	        std::cerr &lt;&lt; e.what() &lt;&lt; '\n';
	    }
	
	    return 0;
	}
</code></pre>
<p>O resultado da execução será:</p>
<pre><code>74.125.24.101:443
74.125.24.139:443
74.125.24.138:443
74.125.24.102:443
74.125.24.100:443
74.125.24.113:443
</code></pre>
<p>O elemento <code>boost::asio::ip::tcp::resolver::results_type</code> é o iterador de <code>basic_resolver_entry</code>: </p>
<pre><code class="language-cpp">	template &lt;typename InternetProtocol&gt;
	class basic_resolver_entry
	{
	......
	public:
	  /// The protocol type associated with the endpoint entry.
	  typedef InternetProtocol protocol_type;
	
	  /// The endpoint type associated with the endpoint entry.
	  typedef typename InternetProtocol::endpoint endpoint_type;
	......
	  /// Convert to the endpoint associated with the entry.
	  operator endpoint_type() const
	  {
	    return endpoint_;
	  }
	......
	}
</code></pre>
<p>Como ele possui o operador <code>endpoint_type()</code>, ele pode ser convertido diretamente no endpoint:</p>
<pre><code class="language-cpp">	boost::asio::ip::tcp::endpoint endpoint = *it;
</code></pre>
<p>Em resumo, o objeto <code>asio::ip::tcp::resolver</code> do Asio é usado para resolver nomes de domínio em endereços IP. Ele fornece uma série de funcionalidades úteis, como a possibilidade de resolver o nome de domínio de forma assíncrona e de cancelar a resolução de um nome de domínio em andamento.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exceção"><a class="header" href="#exceção">Exceção</a></h1>
<p>O Asio fornece uma série de exceções de erro que podem ser lançadas em situações em que ocorrem erros durante a execução de operações de rede. Essas exceções são derivadas da classe <code>boost::system::system_error</code> e incluem:</p>
<ul>
<li><code>boost::asio::error::address_family_not_supported</code>: lançada quando o tipo de endereço especificado não é suportado pela plataforma.</li>
<li><code>boost::asio::error::address_in_use</code>: lançada quando o endereço especificado já está em uso por outro processo.</li>
<li><code>boost::asio::error::connection_aborted</code>: lançada quando a conexão é abortada pelo host remoto.</li>
<li><code>boost::asio::error::connection_refused</code>: lançada quando a conexão é recusada pelo host remoto.</li>
<li><code>boost::asio::error::connection_reset</code>: lançada quando a conexão é reiniciada pelo host remoto.</li>
</ul>
<p>Essas exceções são lançadas pelos métodos do Asio que realizam operações de rede, como <code>boost::asio::ip::tcp::acceptor::accept</code> ou <code>boost::asio::ip::tcp::socket::connect</code>. Elas podem ser capturadas pelo programa e tratadas de acordo com o erro específico que ocorreu.</p>
<p>As funções do <code>Asio</code> podem gerar a exceção <code>boost::system::system_error</code>. Veja o <a href="cpp-asio/dns-query.html"><code>resolve</code></a> no exemplo abaixo:</p>
<pre><code class="language-cpp">	results_type resolve(BOOST_ASIO_STRING_VIEW_PARAM host,
		BOOST_ASIO_STRING_VIEW_PARAM service, resolver_base::flags resolve_flags)
	{
	  boost::system::error_code ec;
	  ......
	  boost::asio::detail::throw_error(ec, &quot;resolve&quot;);
	  return r;
	}
</code></pre>
<p>Há duas sobrecargas de funções <code>boost::asio::detail::throw_error</code>:</p>
<pre><code class="language-cpp">	inline void throw_error(const boost::system::error_code&amp; err)
	{
	  if (err)
	    do_throw_error(err);
	}
	
	inline void throw_error(const boost::system::error_code&amp; err,
	    const char* location)
	{
	  if (err)
	    do_throw_error(err, location);
	}
</code></pre>
<p>As diferenças dessas duas funções é que estão apenas incluindo a string &quot;location&quot; (&quot;<code>resolve</code>&quot; no nosso exemplo) ou não. Assim, o <code>do_throw_error</code> também tem duas sobrecargas, veja uma como exemplo:</p>
<pre><code class="language-cpp">	void do_throw_error(const boost::system::error_code&amp; err, const char* location)
	{
	  boost::system::system_error e(err, location);
	  boost::asio::detail::throw_exception(e);
	}
</code></pre>
<p><code>boost::system::system_error</code> deriva de <code>std::runtime_error</code>:</p>
<pre><code class="language-cpp">	class BOOST_SYMBOL_VISIBLE system_error : public std::runtime_error
	{
	......
	public:
	      system_error( error_code ec )
	          : std::runtime_error(&quot;&quot;), m_error_code(ec) {}
	
	      system_error( error_code ec, const std::string &amp; what_arg )
	          : std::runtime_error(what_arg), m_error_code(ec) {}
	......
	      const error_code &amp;  code() const BOOST_NOEXCEPT_OR_NOTHROW { return m_error_code; }
	      const char *        what() const BOOST_NOEXCEPT_OR_NOTHROW;
	......
	}
</code></pre>
<p>A função membro chamado <code>what()</code> retorna as informações detalhadas da exceção.</p>
<p>Em resumo, o Asio fornece uma série de exceções de erro que podem ser lançadas em situações em que ocorrem erros durante a execução de operações de rede. Essas exceções são derivadas da classe <code>boost::system::system_error</code> ou <code>asio::system_error</code> (<strong>standalone</strong>) e incluem erros comuns de rede, como conexão abortada, conexão recusada ou endereço em uso. Elas podem ser capturadas pelo programa e tratadas de acordo com o erro específico que ocorreu.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conectar-servidor"><a class="header" href="#conectar-servidor">Conectar Servidor</a></h1>
<p>O cliente pode usar os endpoints retornados por <a href="cpp-asio/dns-query.html">DNS</a> para conectar o aplicativo servidor. Veja o código abaixo:</p>
<pre><code class="language-cpp">	#include &lt;boost/asio.hpp&gt;
	#include &lt;iostream&gt;
	
	int main()
	{
	    try
	    {
	        boost::asio::io_context io_context;
	
	        boost::asio::ip::tcp::resolver resolver{io_context};
	        boost::asio::ip::tcp::resolver::results_type endpoints =
	                resolver.resolve(&quot;google.com&quot;, &quot;https&quot;);
	
	        boost::asio::ip::tcp::tcp::socket socket{io_context};
	        auto endpoint = boost::asio::connect(socket, endpoints);
	
	        std::cout &lt;&lt; &quot;Connect to &quot; &lt;&lt; endpoint &lt;&lt; &quot; successfully!\n&quot;;
	    }
	    catch (std::exception&amp; e)
	    {
	        std::cerr &lt;&lt; e.what() &lt;&lt; '\n';
	        return -1;
	    }
	
	    return 0;
	}
</code></pre>
<p>O resultado da execução será:</p>
<pre><code>Connect to 172.217.194.101:443 successfully!
</code></pre>
<p>Observe que o <code>boost::asio::connect</code> requer o iterador de endpoints. Se você quiser apenas um endpoint específico, poderá usar a função membro <code>connect</code> do socket. Verifique o código abaixo:</p>
<pre><code class="language-cpp">	#include &lt;boost/asio.hpp&gt;
	#include &lt;iostream&gt;
	
	int main()
	{
	    try
	    {
	        boost::asio::io_context io_context;
	
	        boost::asio::ip::tcp::resolver resolver{io_context};
	        boost::asio::ip::tcp::resolver::results_type endpoints =
	                resolver.resolve(&quot;google.com&quot;, &quot;https&quot;);
	
	        boost::asio::ip::tcp::tcp::socket socket{io_context};
	        auto eit = endpoints.cbegin();
	        for (; eit != endpoints.cend(); eit++)
	        {
	            boost::system::error_code ec;
	            boost::asio::ip::tcp::endpoint endpoint = *eit;
	            socket.connect(endpoint, ec);
	            if (!ec)
	            {
	                std::cout &lt;&lt; &quot;Connect to &quot; &lt;&lt; endpoint &lt;&lt; &quot; successfully!\n&quot;;
	                break;
	            }
	        }
	
	        if (eit == endpoints.cend())
	        {
	            std::cout &lt;&lt; &quot;Connect failed!\n&quot;;
	            return  -1;
	        }
	    }
	    catch (std::exception&amp; e)
	    {
	        std::cerr &lt;&lt; e.what() &lt;&lt; '\n';
	        return -1;
	    }
	
	    return 0;
	}
</code></pre>
<p>O resultado da execução será:</p>
<pre><code>Connect to 172.217.194.139:443 successfully!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accept-connections"><a class="header" href="#accept-connections">Accept connections</a></h1>
<p>Para que o servidor aceite a conexão dos clientes. O servidor precisará criar um <code>acceptor</code>:</p>
<pre><code class="language-cpp">	......
	boost::asio::io_context io_context;
        boost::asio::ip::tcp::acceptor acceptor{
            io_context,
            boost::asio::ip::tcp::endpoint{boost::asio::ip::tcp::v6(), 3303}};
	......
</code></pre>
<p><code>boost::asio::ip::tcp::acceptor</code> é uma instância de <code>basic_socket_acceptor</code>:</p>
<pre><code class="language-cpp">	class tcp
	{
	......
	  /// The TCP acceptor type.
	  typedef basic_socket_acceptor&lt;tcp&gt; acceptor;
	......
	}
</code></pre>
<p>O construtor <code>basic_socket_acceptor</code> combinará criação de socket, configuração de endereço de reutilização, funções binding &amp; listening:</p>
<pre><code class="language-cpp">	basic_socket_acceptor(boost::asio::io_context&amp; io_context,
	    const endpoint_type&amp; endpoint, bool reuse_addr = true)
	  : basic_io_object&lt;BOOST_ASIO_SVC_T&gt;(io_context)
	{
	......
	}
</code></pre>
<p>Então o <code>acceptor</code> aceitará as conexões dos clientes. O código abaixo mostra o endereço do cliente e fecha a conexão:</p>
<pre><code class="language-cpp">	#include &lt;boost/asio.hpp&gt;
	#include &lt;iostream&gt;
	
	int main()
	{
	    try
	    {
	        boost::asio::io_context io_context;
	        boost::asio::ip::tcp::acceptor acceptor{
	            io_context,
	            boost::asio::ip::tcp::endpoint{boost::asio::ip::tcp::v6(), 3303}};
	
	        while (1)
	        {
	            boost::asio::ip::tcp::socket socket{io_context};
	            acceptor.accept(socket);
	
	            std::cout &lt;&lt; socket.remote_endpoint() &lt;&lt; &quot; connects to &quot; &lt;&lt; socket.local_endpoint() &lt;&lt; '\n';
	        }
	    }
	    catch (std::exception&amp; e)
	    {
	        std::cerr &lt;&lt; e.what() &lt;&lt; '\n';
	        return -1;
	    }
	
	    return 0;
	}
</code></pre>
<p>O resultado da execução será:</p>
<pre><code>[::ffff:10.217.242.61]:39290 connects to [::ffff:192.168.35.145]:3303
......
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operações-síncronas-es"><a class="header" href="#operações-síncronas-es">Operações síncronas E/S</a></h1>
<p>Depois que a conexão é estabelecida, o cliente e o servidor podem se comunicar. Como na API sockets do <code>UNIX</code>, o <code>boost::asio</code> também fornece as funções <code>send</code> e<code> receive</code> Use <code>basic_stream_socket</code> como exemplo e um par de implementações assim:</p>
<pre><code class="language-cpp">	template &lt;typename ConstBufferSequence&gt;
  	std::size_t send(const ConstBufferSequence&amp; buffers)
	{
		......
	}
	......
	template &lt;typename MutableBufferSequence&gt;
  	std::size_t receive(const MutableBufferSequence&amp; buffers)
	{
		......
	}
</code></pre>
<p>Observe que os tipos de buffer de <code>send/receive</code> são <code>ConstBufferSequence/MutableBufferSequence</code>, e podemos usar a função <code>boost::asio::buffer</code> para construir tipos relacionados.</p>
<p>Abaixo está um programa cliente que envia &quot;<code>Hello world!</code>&quot; Para o servidor após o estabelecimento da conexão:</p>
<pre><code class="language-cpp">	#include &lt;boost/asio.hpp&gt;
	#include &lt;iostream&gt;
	
	int main()
	{
	    try
	    {
	        boost::asio::io_context io_context;
	
	        boost::asio::ip::tcp::endpoint endpoint{
	                boost::asio::ip::make_address(&quot;10.217.242.61&quot;),
	                3303};
	        boost::asio::ip::tcp::tcp::socket socket{io_context};
	        socket.connect(endpoint);
	
	        std::cout &lt;&lt; &quot;Connect to &quot; &lt;&lt; endpoint &lt;&lt; &quot; successfully!\n&quot;;
	
	        socket.send(boost::asio::buffer(&quot;Hello world!&quot;));
	    }
	    catch (std::exception&amp; e)
	    {
	        std::cerr &lt;&lt; e.what() &lt;&lt; '\n';
	        return -1;
	    }
	
	    return 0;
	}
</code></pre>
<p>O programa servidor que aguarda o recebimento da saudação do cliente:</p>
<pre><code class="language-cpp">	#include &lt;boost/asio.hpp&gt;
	#include &lt;iostream&gt;
	
	int main()
	{
	    try
	    {
	        boost::asio::io_context io_context;
	        boost::asio::ip::tcp::acceptor acceptor{
	                io_context,
	                boost::asio::ip::tcp::endpoint{boost::asio::ip::tcp::v4(), 3303}};
	
	        while (1)
	        {
	            boost::asio::ip::tcp::socket socket{io_context};
	            acceptor.accept(socket);
	
	            std::cout &lt;&lt; socket.remote_endpoint() &lt;&lt; &quot; connects to &quot; &lt;&lt; socket.local_endpoint() &lt;&lt; '\n';
	
	            char recv_str[1024] = {};
	            socket.receive(boost::asio::buffer(recv_str));
	
	            std::cout &lt;&lt; &quot;Receive string: &quot; &lt;&lt; recv_str &lt;&lt; '\n';
	        }
	    }
	    catch (std::exception&amp; e)
	    {
	        std::cerr &lt;&lt; e.what() &lt;&lt; '\n';
	        return -1;
	    }
	
	    return 0;
	}
</code></pre>
<p>Compile e execute os programas. O cliente exibirá o seguinte:</p>
<pre><code>$ ./client
Connect to 10.217.242.61:3303 successfully!
</code></pre>
<p>Servidor exibirá  seguinte:</p>
<pre><code>$ ./server
10.217.242.21:64776 connects to 10.217.242.61:3303
Receive string: Hello world!
</code></pre>
<p>Se nenhum erro ocorrer, o <code>send</code> pode garantir que pelo menos um byte seja enviado com sucesso, e você deve verificar o valor de retorno para ver se todos os bytes foram enviados com sucesso ou não. <code>receive</code> é semelhante a <code>send</code>. O <code>boost::asio::basic_stream_socket</code> também fornece<code> read_some</code> e <code>write_some</code>, que têm as mesmas funções que <code>receive</code> e <code>send</code>.</p>
<p>Se não nos preocuparmos em verificar o estado do meio (bytes parciais são enviados com sucesso), e apenas nos importarmos se todos os bytes serão enviados com sucesso ou não, podemos usar o <code>boost::asio::write</code> que usa o <code>write_some</code> por baixo. Da mesma forma, não é difícil adivinhar o que <code>boost::asio::read</code> faz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operações-assíncronas-es"><a class="header" href="#operações-assíncronas-es">Operações Assíncronas E/S</a></h1>
<p>Diferentemente da API sockets do <code>UNIX</code>, o<code> Asio</code> possui habilidades de leitura &amp; gravação(read/write) assíncronas inclusas. Ainda pode usar <code>basic_stream_socket</code> como exemplo, e um par de implementações assim:</p>
<pre><code class="language-cpp">	template &lt;typename ConstBufferSequence, typename WriteHandler&gt;
	  BOOST_ASIO_INITFN_RESULT_TYPE(WriteHandler,
	      void (boost::system::error_code, std::size_t))
	  async_send(const ConstBufferSequence&amp; buffers,
	      BOOST_ASIO_MOVE_ARG(WriteHandler) handler)
	{
		.......
	}
	template &lt;typename MutableBufferSequence, typename ReadHandler&gt;
	  BOOST_ASIO_INITFN_RESULT_TYPE(ReadHandler,
	      void (boost::system::error_code, std::size_t))
	  async_receive(const MutableBufferSequence&amp; buffers,
	      BOOST_ASIO_MOVE_ARG(ReadHandler) handler)
	{
		.......
	}
</code></pre>
<p>Como as funções <code>async_send</code> e <code>async_receive</code> retornam imediatamente, e não bloqueiam a thread atual, você deve passar uma função de retorno de chamada como o parâmetro que recebe o resultado das operações de leitura &amp; gravação:</p>
<pre><code class="language-cpp">	void handler(
		const boost::system::error_code&amp; error, // Result of operation.
		std::size_t bytes_transferred           // Number of bytes processed.
	)
</code></pre>
<p>Há um exemplo simples de cliente/servidor. Abaixo está o código do cliente:</p>
<pre><code class="language-cpp">	#include &lt;boost/asio.hpp&gt;
	#include &lt;functional&gt;
	#include &lt;iostream&gt;
	#include &lt;memory&gt;
	
	void callback(
	        const boost::system::error_code&amp; error,
	        std::size_t bytes_transferred,
	        std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; socket,
	        std::string str)
	{
	    if (error)
	    {
	        std::cout &lt;&lt; error.message() &lt;&lt; '\n';
	    }
	    else if (bytes_transferred == str.length())
	    {
	        std::cout &lt;&lt; &quot;Message is sent successfully!&quot; &lt;&lt; '\n';
	    }
	    else
	    {
	        socket-&gt;async_send(
	                boost::asio::buffer(str.c_str() + bytes_transferred, str.length() - bytes_transferred),
	                std::bind(callback, std::placeholders::_1, std::placeholders::_2, socket, str));
	    }
	}	
	
	int main()
	{
	    try
	    {
	        boost::asio::io_context io_context;
	
	        boost::asio::ip::tcp::endpoint endpoint{
	                boost::asio::ip::make_address(&quot;192.168.35.145&quot;),
	                3303};
	
	        std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; socket{new boost::asio::ip::tcp::socket{io_context}};
	        socket-&gt;connect(endpoint);
	
	        std::cout &lt;&lt; &quot;Connect to &quot; &lt;&lt; endpoint &lt;&lt; &quot; successfully!\n&quot;;
	
	        std::string str{&quot;Hello world!&quot;};
	        socket-&gt;async_send(
	                boost::asio::buffer(str),
	                std::bind(callback, std::placeholders::_1, std::placeholders::_2, socket, str));
	        socket-&gt;get_executor().context().run();
	    }
	    catch (std::exception&amp; e)
	    {
	        std::cerr &lt;&lt; e.what() &lt;&lt; '\n';
	        return -1;
	    }
	
	    return 0;
	}
</code></pre>
<p>Vamos analisar o código:</p>
<p>(1) Como o objeto sockets é non-copyable (<a href="cpp-asio/socket.html">sockets</a>), sockets é criado como um ponteiro inteligente de memória compartilhada (shared_pointer):</p>
<pre><code class="language-cpp">	......
	std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; socket{new boost::asio::ip::tcp::socket{io_context}};
	......
</code></pre>
<p>(2) Como o <code>callback</code> possui apenas dois parâmetros, ele precisa usar <code>std::bind</code> para passar parâmetros adicionais:</p>
<pre><code class="language-cpp">	......
	std::bind(callback, std::placeholders::_1, std::placeholders::_2, socket, str)
	......
</code></pre>
<p>(3) <code>async_send</code> não garante que todos os bytes sejam enviados (<code>boost::asio::async_write</code> retorna todos os bytes enviados com sucesso ou ocorre um erro), portanto, é necessário reemitir <code>async_send</code> no <code>callback</code>:</p>
<pre><code class="language-cpp">	......
	if (error)
	{
	    ......
	}
	else if (bytes_transferred == str.length())
	{
	    ......
	}
	else
	{
	    socket-&gt;async_send(......);
	}
</code></pre>
<p>(4) A função <code>io_context.run</code> será bloqueada até que todo o trabalho termine e não haja mais handlers(manipuladores) a serem despachados, ou até que o<code> io_context</code> seja interrompido:</p>
<pre><code class="language-cpp">	socket-&gt;get_executor().context().run();
</code></pre>
<p>Se não houver a função <code>io_context.run</code>, o programa será encerrado imediatamente.</p>
<p>Verifique o código do servidor que usa <code>async_receive</code>:</p>
<pre><code class="language-cpp">	#include &lt;ctime&gt;
	#include &lt;functional&gt;
	#include &lt;iostream&gt;
	#include &lt;string&gt;
	#include &lt;boost/asio.hpp&gt;
	
	void callback(
	        const boost::system::error_code&amp; error,
	        std::size_t,
	        char recv_str[]) {
	    if (error)
	    {
	        std::cout &lt;&lt; error.message() &lt;&lt; '\n';
	    }
	    else
	    {
	        std::cout &lt;&lt; recv_str &lt;&lt; '\n';
	    }
	}
	
	int main()
	{
	    try
	    {
	        boost::asio::io_context io_context;
	
	        boost::asio::ip::tcp::acceptor acceptor(
	                                        io_context,
	                                        boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), 3303));
	
	        for (;;)
	        {
	            boost::asio::ip::tcp::socket socket(io_context);
	            acceptor.accept(socket);
	
	            char recv_str[1024] = {};
	            socket.async_receive(
	                    boost::asio::buffer(recv_str),
	                    std::bind(callback, std::placeholders::_1, std::placeholders::_2, recv_str));
	            socket.get_executor().context().run();
	            socket.get_executor().context().restart();
	        }
	    }
	    catch (std::exception&amp; e)
	    {
	        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
	    }
	
	    return 0;
	}
</code></pre>
<p>Há duas advertências às quais você precisa prestar atenção:</p>
<p>(1) Apenas para fins de demonstração: para cada cliente, o <code>callback</code> é chamado apenas uma vez;<br />
(2) O <code>io_context.restart</code> deve ser chamado para chamar outro<code> io_context.run</code>.</p>
<p>Da mesma forma, você também pode verificar como usar o <code>boost::asio::async_read</code>.</p>
<p>Compile e execute os programas.</p>
<p>O cliente exibirá o seguinte:</p>
<pre><code>$ ./client
Connect to 192.168.35.145:3303 successfully!
Message is sent successfully!
</code></pre>
<p>Servidor emitirar o seguinte:</p>
<pre><code>$ ./server
Hello world!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protocolo-icmp"><a class="header" href="#protocolo-icmp">Protocolo ICMP</a></h1>
<p>A classe <code>asio::ip::icmp</code> é uma classe em C++ que faz parte da biblioteca Asio (Asynchronous Input/Output) e é usada para implementar a comunicação usando o protocolo ICMP (Internet Control Message Protocol).</p>
<p>O protocolo ICMP é um protocolo de nível de rede que é usado para enviar mensagens de erro e de controle entre dispositivos de rede. Ele é comumente usado para testar a conectividade entre dispositivos de rede, como o comando ping em sistemas operacionais.</p>
<p>A classe <code>asio::ip::icmp</code> fornece uma interface para criar e gerenciar sockets ICMP. Ela é usada para criar sockets ICMP, que são usados para enviar e receber mensagens ICMP. Ela também fornece métodos para enviar e receber mensagens ICMP através de um socket, bem como para gerenciar a conexão e desconexão de clientes.</p>
<p>A classe <code>asio::ip::icmp</code> é derivada da classe <code>asio::basic_socket&lt;Protocol&gt;</code>, que é uma classe genérica que representa um socket de rede. Ela fornece uma interface para criar e gerenciar sockets de rede usando qualquer protocolo de rede suportado pelo Asio. A classe <code>asio::ip::icmp</code> é uma especialização da classe <code>asio::basic_socket&lt;Protocol&gt;</code> para o protocolo ICMP.</p>
<p>A classe <code>asio::ip::icmp</code> fornece os seguintes métodos e funcionalidades:</p>
<ul>
<li><code>connect</code>: estabelece uma conexão com um host especificado através de um endpoint ICMP.</li>
<li><code>close</code>: fecha o socket e interrompe qualquer conexão existente.</li>
<li><code>read</code>: lê dados de um socket e armazena os dados em um buffer de saída.</li>
<li><code>write</code>: escreve dados de um buffer em um socket.</li>
</ul>
<p>Além disso, a classe <code>asio::ip::icmp</code> fornece várias configurações de socket, como opções de buffer de entrada e saída, opções de tempo de espera e opções de recurso. Essas opções podem ser ajustadas usando os métodos set_option e get_option da classe <code>asio::ip::icmp</code>.</p>
<p>Aqui está um exemplo de como a classe <code>asio::ip::icmp</code> pode ser usada para implementar um programa em C++ que envia uma mensagem ICMP para um host especificado e aguarda por uma resposta:</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;chrono&gt;
#include &lt;asio.hpp&gt;


// Constantes para os campos protocol e type
const unsigned char IPPROTO_ICMP = 1;
const unsigned char ICMP_ECHO = 8;
const unsigned char ICMP_ECHOREPLY = 0;
const unsigned char ICMP_DEST_UNREACH = 3;
const unsigned char ICMP_TIME_EXCEEDED = 11;

struct iphdr
{
    unsigned char  ihl:4;
    unsigned char  version:4;
    unsigned char  tos;
    unsigned short tot_len;
    unsigned short id;
    unsigned short frag_off;
    unsigned char  ttl;
    unsigned char  protocol;
    unsigned short check;
    unsigned int   saddr;
    unsigned int   daddr;
};

struct icmphdr
{
    unsigned char  type;
    unsigned char  code;
    unsigned short checksum;
    union un
    {
        struct echo
        {
            unsigned short id;
            unsigned short sequence;
        };
        unsigned int   gateway;
        struct frag
        {
            unsigned short __unused;
            unsigned short mtu;
        };
    };
};

int main()
{
    // Cria um objeto io_context doAsio
    asio::io_context io_context;

    // Cria um socket ICMP
    asio::ip::icmp::socket socket(io_context);

    // Configura um endpoint ICMP para o host
    asio::ip::icmp::endpoint host_endpoint(&quot;www.example.com&quot;, 0);

    // Conecta o socket ao host
    socket.connect(host_endpoint);

    // Envia um ping para o host
    std::vector&lt;unsigned char&gt; ping(sizeof(icmphdr) + sizeof(iphdr) + 8);
    iphdr* ip_header = reinterpret_cast&lt;iphdr*&gt;(ping.data());
    ip_header-&gt;ihl = 5;
    ip_header-&gt;version = 4;
    ip_header-&gt;tot_len = htons(ping.size());
    ip_header-&gt;protocol = IPPROTO_ICMP;
    ip_header-&gt;saddr = inet_addr(&quot;127.0.0.1&quot;);
    ip_header-&gt;daddr = inet_addr(&quot;www.example.com&quot;);
    icmphdr* icmp_header = reinterpret_cast&lt;icmphdr*&gt;(ping.data() + sizeof(iphdr));
    icmp_header-&gt;type = ICMP_ECHO;
    icmp_header-&gt;code = 0;
    icmp_header-&gt;un.echo.id = htons(1234);
    icmp_header-&gt;un.echo.sequence = htons(1);
    *reinterpret_cast&lt;unsigned long*&gt;(ping.data() + sizeof(icmphdr) + sizeof(iphdr)) = htonl(time(nullptr));

    // Calcula o checksum do ping
    icmp_header-&gt;checksum = 0;
    icmp_header-&gt;checksum = asio::ip::icmp::checksum(ping.data(), ping.size());

    // Armazena o tempo de envio do ping
    auto send_time = std::chrono::high_resolution_clock::now();

    // Envia o ping para o host
    asio::write(socket,asio::buffer(ping));

    // Aguarda por uma resposta de ping do host
    std::vector&lt;unsigned char&gt; reply(1024);
    size_t bytes_received = asio::read(socket, asio::buffer(reply));

    // Verifica se o tipo de mensagem recebida é um ICMP_ECHOREPLY
    iphdr* reply_ip_header = reinterpret_cast&lt;iphdr*&gt;(reply.data());
    icmphdr* reply_icmp_header = reinterpret_cast&lt;icmphdr*&gt;(reply.data() + (reply_ip_header-&gt;ihl * 4));
    if (reply_icmp_header-&gt;type == ICMP_ECHOREPLY)
    {
        // Calcula o tempo de viagem do ping
        auto trip_time = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(std::chrono::high_resolution_clock::now() - send_time).count();

        // Imprime o resultado do ping
        std::cout &lt;&lt; &quot;Recebida resposta de ping do host em &quot; &lt;&lt; trip_time &lt;&lt; &quot; ms&quot; &lt;&lt; std::endl;
    }
    else
    {
        std::cout &lt;&lt; &quot;Tipo de mensagem não reconhecido&quot; &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protocolo-raw"><a class="header" href="#protocolo-raw">Protocolo Raw</a></h1>
<p>Uma das funcionalidades que aAsio oferece é a possibilidade de enviar e receber pacotes de dados usando o protocolo de rede a baixo nível. Isso é conhecido como &quot;envio/recebimento de pacotes raw&quot;, ou simplesmente &quot;raw sockets&quot;.</p>
<p>A classe <code>asio::generic::raw_protocol</code> é usada para implementar a comunicação de pacotes e também fornece uma interface para criar e gerenciar sockets de pacotes raw. Ela também fornece métodos para enviar e receber pacotes raw através de um socket, bem como para gerenciar a conexão e desconexão de clientes.
Para usar raw sockets com aAsio, é necessário incluir o cabeçalho <code>&lt;asio/generic/raw_socket.hpp&gt;</code> e criar uma instância de <code>asio::generic::raw_protocol</code>, que é a classe responsável por gerenciar a conexão de rede.</p>
<p>Os pacotes raw são pacotes de rede que são enviados e recebidos diretamente, sem qualquer tipo de encapsulamento ou formatação adicional. Eles são usados para implementar protocolos de nível inferior, como o protocolo ICMP, ou para fazer debug de aplicações de rede.</p>
<p>Exemplo de código para enviar um pacote raw:</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;boost/asio/io_context.hpp&gt;
#include &lt;boost/asio/generic/raw_socket.hpp&gt;
#include &lt;boost/asio/ip/udp.hpp&gt;

namespace asio = boost::asio;

int main() {
  asio::io_context io_context;
  asio::basic_raw_socket&lt;asio::generic::raw_protocol&gt; socket(io_context);

  // Cria um buffer com os dados a serem enviados
  std::vector&lt;std::uint8_t&gt; data = {0x01, 0x02, 0x03, 0x04};
  asio::const_buffer buffer(data.data(), data.size());

  // Envia o pacote para o endereço IP e porta especificados
  socket.send_to(buffer, asio::ip::udp::endpoint(asio::ip::make_address(&quot;127.0.0.1&quot;), 1234));

  return 0;
}
</code></pre>
<p>O exemplo acima mostra como enviar um pacote raw para o endereço IP &quot;127.0.0.1&quot; na porta 1234. O pacote é criado como um buffer de dados e enviado através da chamada ao método <code>send_to()</code> do socket para enviar o buffer de dados para o endereço IP e porta especificados usando o tipo <code>asio::ip::udp::endpoint</code>.</p>
<p>Para receber pacotes raw, basta chamar o método <code>receive_from()</code> do socket, passando um buffer para armazenar os dados recebidos.</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;boost/asio/io_context.hpp&gt;
#include &lt;boost/asio/generic/raw_socket.hpp&gt;
#include &lt;boost/asio/ip/udp.hpp&gt;

namespace asio = boost::asio;

int main() {
  asio::io_context io_context;
  asio::basic_raw_socket&lt;asio::generic::raw_protocol&gt; socket(io_context);

  // Liga o soquete a uma porta específica
  socket.bind(asio::ip::udp::endpoint(asio::ip::make_address(&quot;127.0.0.1&quot;), 1234));

  // Recebe os dados através do soquete raw
  char recv_buf[1024];
  asio::ip::udp::endpoint sender_endpoint;
  size_t bytes_received = socket.receive_from(
  asio::buffer(recv_buf, sizeof(recv_buf)), sender_endpoint);

  // Imprime os dados do endpoint
  std::cout &lt;&lt; &quot;Received &quot; &lt;&lt; bytes_received &lt;&lt; &quot; bytes from &quot;;
  std::cout.write(reinterpret_cast&lt;char*&gt;(sender_endpoint.data()), sender_endpoint.size());
  std::cout &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Data: &quot; &lt;&lt; recv_buf &lt;&lt; std::endl;

  return 0;
}
</code></pre>
<p>No exemplo acima, o socket é conectado ao endereço IP &quot;127.0.0.1&quot; na porta 1234 e cria um buffer para armazenar os dados recebidos. Em seguida, é chamado o método <code>receive_from()</code> do socket, que bloqueia a execução do programa até que um pacote seja recebido. Quando o pacote é recebido, usamos a função data para obter um ponteiro para os dados do endpoint e a função size para obter o tamanho dos dados. Em seguida, usamos a função write da classe ostream para escrever os dados na tela. Porém, o tipo <code>basic_endpoint&lt;raw_protocol&gt;::data_type</code> é um ponteiro para um <code>sockaddr</code>, enquanto o tipo esperado pela função write é um ponteiro para o tipo caractere (<code>char*</code>). Para corrigir isso, basta usar o operador <code>reinterpret_cast</code> para converter o ponteiro para <code>sockaddr</code> em um ponteiro para caractere. Isso permite que a função write seja chamada com os dados do endpoint.</p>
<p>É importante notar que, ao trabalhar com pacotes raw, é necessário se preocupar com os detalhes da camada de rede (como cabeçalhos de protocolo, endereçamento, etc.), o que pode ser complexo e trabalhoso. Além disso, o envio/recebimento de pacotes raw geralmente só é necessário em casos especiais, como quando é preciso implementar um protocolo de rede customizado ou realizar testes de baixo nível. Em muitos casos, é mais conveniente usar um protocolo de rede mais alto nível, como o TCP ou o UDP, que já fornecem muitas das funcionalidades necessárias para a comunicação de rede.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protocolo-udp"><a class="header" href="#protocolo-udp">Protocolo UDP</a></h1>
<p>Nós discutimos como se comunicar através do <a href="https://pt.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a> o suficiente, então é hora de mudar para o <a href="https://pt.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a> agora. O <a href="https://pt.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a> é um protocolo sem conexão e não confiável, mas é mais fácil de usar que o <a href="https://pt.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a>.</p>
<p>Há um exemplo de Cliente/Servidor. </p>
<h3 id="cliente"><a class="header" href="#cliente"><em>Cliente</em>:</a></h3>
<pre><code class="language-cpp">	#include &lt;boost/asio.hpp&gt;
	#include &lt;iostream&gt;
	
	int main()
	{
	    try
	    {
	        boost::asio::io_context io_context;
	
	        boost::asio::ip::udp::socket socket{io_context};
	        socket.open(boost::asio::ip::udp::v4());
	
	        socket.send_to(
	                boost::asio::buffer(&quot;Welcome to C++ Networking.&quot;),
	                boost::asio::ip::udp::endpoint{boost::asio::ip::make_address(&quot;192.168.35.145&quot;), 3303});
	    }
	    catch (std::exception&amp; e)
	    {
	        std::cerr &lt;&lt; e.what() &lt;&lt; '\n';
	        return -1;
	    }
	
	    return 0;
	}
</code></pre>
<p>Embora não seja necessário chamar a função <code>socket.connect</code>, você precisa chamar explicitamente o <code>socket.open</code>. Além disso, o <code>endpoint</code> do servidor precisa ser especificado ao chamar <code>socket.send_to</code>.</p>
<h3 id="servidor"><a class="header" href="#servidor"><em>Servidor</em>:</a></h3>
<pre><code class="language-cpp">	#include &lt;ctime&gt;
	#include &lt;functional&gt;
	#include &lt;iostream&gt;
	#include &lt;string&gt;
	#include &lt;boost/asio.hpp&gt;
	
	int main()
	{
	    try
	    {
	        boost::asio::io_context io_context;
	
	        for (;;)
	        {
	            boost::asio::ip::udp::socket socket(
	                    io_context,
	                    boost::asio::ip::udp::endpoint{boost::asio::ip::udp::v4(), 3303});
	
	            boost::asio::ip::udp::endpoint client;
	            char recv_str[1024] = {};
	
	            socket.receive_from(
	                    boost::asio::buffer(recv_str),
	                    client);
	            std::cout &lt;&lt; client &lt;&lt; &quot;: &quot; &lt;&lt; recv_str &lt;&lt; '\n';
	        }
	    }
	    catch (std::exception&amp; e)
	    {
	        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
	    }
	
	    return 0;
	}
</code></pre>
<p>Muito fácil, não é? Crie e execute o cliente e servidor. Então o seguinte log será impresso no lado do servidor:</p>
<pre><code class="language-bash">$ ./servidor
10.217.242.21:63838: Welcome to C++ Networking.
10.217.242.21:61259: Welcome to C++ Networking.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ssltls"><a class="header" href="#ssltls">SSL/TLS</a></h2>
<p>SSL (Secure Sockets Layer) e TLS (Transport Layer Security) são dois protocolos de segurança que são amplamente utilizados na internet para proteger as comunicações entre dispositivos. Ambos são baseados em certificados de segurança e chaves criptográficas, que são usados ​​para criptografar e decriptar os dados transmitidos.</p>
<p>A principal diferença entre SSL e TLS é que TLS é uma versão atualizada e aprimorada do SSL. O SSL foi originalmente criado pela Netscape nos anos 1990 como uma maneira de proteger as comunicações na internet. No entanto, com o tempo, alguns problemas de segurança foram encontrados no SSL, o que levou ao desenvolvimento do TLS como uma substituição.</p>
<p>O TLS foi projetado para corrigir os problemas de segurança encontrados no SSL e fornecer um nível ainda maior de segurança nas comunicações na internet. Ele é compatível com o SSL, o que significa que os dispositivos que suportam o TLS também podem se comunicar com dispositivos que usam o SSL.</p>
<p>Apesar da similaridade entre SSL e TLS, a maioria dos sites da web e serviços de internet atualmente usa o TLS para proteger suas comunicações. Isso é porque o TLS é considerado mais seguro e atualizado do que o SSL. No entanto, o SSL ainda é amplamente utilizado em algumas aplicações, como em conexões seguras de email (SMTPS) e em alguns protocolos de VPN.</p>
<h3 id="asio-ssl"><a class="header" href="#asio-ssl">Asio SSL</a></h3>
<p>A biblioteca Asio SSL fornece uma API que permite aos desenvolvedores criar e gerenciar conexões seguras usando o protocolo SSL (Secure Sockets Layer) ou TLS (Transport Layer Security). Ela inclui funções para realizar handshakes SSL/TLS, criptografar e decriptar dados usando chaves criptográficas e verificar a validade de certificados de segurança.</p>
<p>Aqui está um exemplo completo de código em C++ que demonstra como usar a biblioteca Asio SSL para estabelecer uma conexão segura com um servidor e enviar uma solicitação HTTP. Este exemplo supõe que você já tenha incluído os cabeçalhos relevantes e configurado o objeto asio::ssl::context de acordo com suas necessidades.</p>
<pre><code class="language-c++">#include &lt;asio/ssl.hpp&gt;
#include &lt;asio/ip/tcp.hpp&gt;

#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

int main()
{
    asio::io_context io_context;

    // Criar um objeto asio::ssl::context com as configurações SSL/TLS desejadas
    asio::ssl::context ctx(asio::ssl::context::sslv23);
    ctx.set_options(asio::ssl::context::default_workarounds
                     | asio::ssl::context::no_sslv2
                     | asio::ssl::context::single_dh_use);
    ctx.use_certificate_chain_file(&quot;certificate.pem&quot;);
    ctx.use_private_key_file(&quot;key.pem&quot;, asio::ssl::context::pem);

    // Criar um objeto asio::ssl::stream usando o objeto asio::ssl::context
    asio::ssl::stream&lt;asio::ip::tcp::socket&gt; socket(io_context, ctx);

    // Conectar ao servidor
    socket.lowest_layer().connect({{}, 443});

    // Realizar o handshake SSL como um cliente
    socket.handshake(asio::ssl::stream_base::client);

    // Enviar a solicitação HTTP
    std::string request = &quot;GET / HTTP/1.1\r\nHost: example.com\r\n\r\n&quot;;
    asio::write(socket, asio::buffer(request));

    // Receber a resposta do servidor
    std::vector&lt;char&gt; response(1024);
    asio::read(socket, asio::buffer(response));

    std::cout &lt;&lt; &quot;Response from server: &quot; &lt;&lt; std::string(response.data(), response.size()) &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p>Neste exemplo, primeiro criamos um objeto <code>asio::ssl::context</code> com as configurações SSL/TLS desejadas. Em seguida, criamos um objeto <code>asio::ssl::stream</code> passando o objeto <code>asio::ssl::context</code> como um parâmetro para o construtor.</p>
<p>Em seguida, usamos o método connect do objeto <code>asio::ip::tcp::socket</code> subjacente para estabelecer a conexão com o servidor. Depois disso, realizamos o handshake SSL como um cliente usando o método handshake.</p>
<p>Depois disso, podemos usar os métodos de leitura e escrita padrão, como read e write, para enviar e receber dados através da conexão segura. No exemplo acima, enviamos uma solicitação HTTP simples usando o método write, e depois usamos o método read para ler a resposta do servidor.</p>
<p>Depois de ler a resposta do servidor, podemos exibir o conteúdo da resposta usando o operador de inserção de stream (<code>&lt;&lt;</code>) e o método string da classe <code>std::vector</code>.</p>
<p>Este é um exemplo básico de como usar a biblioteca Asio SSL em aplicativos C++. É importante lembrar que há muitos detalhes adicionais que podem ser considerados ao trabalhar com conexões seguras, como verificação de certificados de segurança, gerenciamento de erros e gerenciamento de sessões SSL/TLS.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="conexão-serial"><a class="header" href="#conexão-serial">Conexão Serial</a></h2>
<p>A conexão serial é um tipo de conexão de comunicação que permite que dois dispositivos se comuniquem por meio de uma porta serial. A porta serial é uma interface física que permite que um dispositivo envie e receba dados por meio de um par de fios. Ela é comumente usada para se comunicar com dispositivos externos, como Arduinos, dispositivos de comunicação industrial e dispositivos de automação.</p>
<h3 id="asio"><a class="header" href="#asio">Asio</a></h3>
<p>A biblioteca Asio inclui suporte para trabalhar com portas seriais, o que permite aos programadores escrever aplicativos que se comunicam com dispositivos seriais, como Arduino e dispositivos de comunicação industrial. Isso é útil quando é preciso enviar ou receber dados de um dispositivo por meio de uma porta serial, como em aplicativos de automação industrial ou em projetos de robótica.</p>
<p>Para usar a biblioteca Asio para trabalhar com portas seriais, é necessário incluir o cabeçalho <code>#include &lt;boost/asio.hpp&gt;</code> no início do seu código. Em seguida, é preciso criar uma instância de um objeto <code>serial_port</code>, que representa a porta serial a ser usada, e passar a ela as informações sobre a porta, como o nome da porta (por exemplo, <code>&quot;COM1&quot;</code> no <strong>Windows</strong> ou <code>&quot;/dev/ttyUSB0&quot;</code> no <strong>Linux</strong>) e a taxa de transmissão (baud rate).</p>
<p>Aqui está um exemplo de código que abre uma porta serial e envia uma mensagem pelo Arduino:</p>
<pre><code class="language-c++">#include &lt;boost/asio.hpp&gt;
#include &lt;iostream&gt;

namespace asio = boost::asio;

int main() {
  // Cria um objeto boost::asio::io_context para gerenciar as operações de entrada/saída.
  asio::io_context io;

  // Cria um objeto boost::asio::serial_port para representar a porta serial.
  asio::serial_port serial(io, &quot;/dev/ttyUSB0&quot;);

  // Configura a porta serial com a taxa de transmissão desejada.
  serial.set_option(asio::serial_port_base::baud_rate(9600));

  // Envia uma mensagem pelo Arduino.
  asio::write(serial, asio::buffer(&quot;Hello, Arduino!\n&quot;));

  return 0;
}
</code></pre>
<p>Além de enviar e receber dados, você também pode configurar várias opções da porta serial usando a biblioteca Asio. Por exemplo, você pode definir o número de bits de dados, a paridade e o número de bits de parada usando as opções <code>serial_port_base::character_size</code>, <code>serial_port_base::parity</code> e <code>serial_port_base::stop_bits</code>, respectivamente. Aqui está um exemplo de como fazer isso:</p>
<pre><code class="language-c++">serial.set_option(boost::asio::serial_port_base::character_size(8));
serial.set_option(boost::asio::serial_port_base::parity(boost::asio::serial_port_base::parity::none));
serial.set_option(boost::asio::serial_port_base::stop_bits(boost::asio::serial_port_base::stop_bits::one));
</code></pre>
<p>Você também pode definir o modo de fluxo de dados da porta serial usando as opções <code>serial_port_base::flow_control</code>. Por exemplo, para habilitar o controle de fluxo hardware (RTS/CTS), você pode usar o seguinte código:</p>
<pre><code class="language-c++">serial.set_option(boost::asio::serial_port_base::flow_control(boost::asio::serial_port_base::flow_control::hardware));
</code></pre>
<p>Além disso, a biblioteca permite que você trate eventos de interrupção da porta serial usando a classe <code>serial_port_service</code>. Isso é útil quando você precisa ser notificado quando a porta serial for interrompida, por exemplo, quando um dispositivo conectado à porta envia um sinal de interrupção. Para usar essa funcionalidade, você precisa criar um objeto <code>serial_port_service</code> e registrar um manipulador de eventos de interrupção usando a função <code>async_wait_for_interrupt()</code>. Aqui está um exemplo de como fazer isso:</p>
<pre><code class="language-c++">#include &lt;boost/asio/serial_port_service.hpp&gt;

// Define uma função de callback para ser chamada quando a interrupção ocorrer.
void interrupt_callback(const boost::system::error_code&amp; error) {
  if (!error) {
    // A interrupção ocorreu. Faça alguma coisa aqui.
    std::cout &lt;&lt; &quot;Interrupt received!&quot; &lt;&lt; std::endl;
  }
}

int main() {
    // Cria um objeto boost::asio::io_context para gerenciar as operações de entrada/saída.
    boost::asio::io_context io;

    // Cria um objeto boost::asio::serial_port para representar a porta serial.
    boost::asio::serial_port serial(io, &quot;/dev/ttyUSB0&quot;);

    // Cria um objeto boost::asio::serial_port_service para tratar eventos de interrupção da porta serial
    boost::asio::serial_port_service serial_service(io);

    // Registra o manipulador de eventos de interrupção.
    serial_service.async_wait_for_interrupt(serial, interrupt_callback);

    // Executa o loop de eventos da biblioteca Asio. Isso fará com que o manipulador de interrupção seja chamado quando a interrupção ocorrer.
    io.run();
}
</code></pre>
<p>Essa é uma maneira de tratar eventos de interrupção da porta serial usando a biblioteca Asio. Note que você precisa executar o loop de eventos (chamando a função <code>io_context::run()</code>) para que os manipuladores de eventos sejam chamados quando os eventos ocorrerem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exemplos"><a class="header" href="#exemplos">Exemplos</a></h1>
<h2 id="cliente-ntp"><a class="header" href="#cliente-ntp">Cliente NTP</a></h2>
<p><strong>Nota:</strong> Nos formatos da data e o timestamp, a base era 0, resultando inicialmente no seguinte horário: 0h de 1 de janeiro de 1900 UTC, quando todos os bits são zero.</p>
<p><strong>Referência:</strong> <a href="https://www.rfc-editor.org/rfc/rfc5905#page-12">RFC 5902</a></p>
<p>Para exibir o horário atual, precisará alterar o timestamp!</p>
<pre><code class="language-c++">#include &lt;array&gt;
#include &lt;boost/asio.hpp&gt;
#include &lt;iostream&gt;
#include &lt;chrono&gt;

namespace asio = boost::asio;
using asio::ip::udp;

int main(int argc, char *argv[]) {
  try {
    if (argc != 2) {
      std::cerr &lt;&lt; &quot;Usage: ntp_client &lt;host&gt;&quot; &lt;&lt; std::endl;
      return 1;
    }

    asio::io_context io_context;

    udp::resolver resolver(io_context);
    udp::endpoint receiver_endpoint =
        *resolver.resolve(udp::v4(), argv[1], &quot;123&quot;).begin();

    udp::socket socket(io_context);
    socket.open(udp::v4());

    std::array&lt;char, 48&gt; send_buf = {0x1b, 0, 0, 0, 0, 0, 0, 0, 0};
    socket.send_to(asio::buffer(send_buf), receiver_endpoint);

    std::array&lt;char, 48&gt; recv_buf;
    udp::endpoint sender_endpoint;
    size_t len = socket.receive_from(asio::buffer(recv_buf), sender_endpoint);

    std::cout &lt;&lt; &quot;received &quot; &lt;&lt; len &lt;&lt; &quot; bytes from &quot; &lt;&lt; sender_endpoint
              &lt;&lt; std::endl;

    // Extrair o NTP timestamp da resposta (do servidor)
    unsigned long long int ntp_timestamp =
      (unsigned long long int)(recv_buf[40]) &lt;&lt; 24 |
      (unsigned long long int)(recv_buf[41]) &lt;&lt; 16 |
      (unsigned long long int)(recv_buf[42]) &lt;&lt; 8 |
      (unsigned long long int)(recv_buf[43]);

   // Converter o timestamp para std::chrono::system_clock::time_point
    std::chrono::system_clock::time_point time_point =
        std::chrono::system_clock::time_point(
            std::chrono::seconds(ntp_timestamp - 2208988800ull));
                              // ntp_timestamp - unix_timestamp

    // Converter o time_point para std::time_t e exibir na tela
    std::time_t time = std::chrono::system_clock::to_time_t(time_point);
    std::cout &lt;&lt; std::ctime(&amp;time) &lt;&lt; std::endl;

  } catch (std::exception &amp;e) {
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
  }

  return 0;
}
</code></pre>
<h2 id="dns-resolver-showmeip"><a class="header" href="#dns-resolver-showmeip">DNS resolver (ShowMeIP)</a></h2>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;asio.hpp&gt;

int main(int argc, char* argv[])
{
    // Verificar o número de argumentos
    if (argc != 2) {
        std::cerr &lt;&lt; &quot;Usage: showip hostname&quot; &lt;&lt; std::endl;
        return 1;
    }

    // Descobrir o endereço IP por baixo do link mencionado no argv[1]
    asio::io_context io_context;
    asio::ip::tcp::resolver resolver(io_context);
    asio::ip::tcp::resolver::query query(argv[1], &quot;&quot;);
    auto results = resolver.resolve(query);

    // Iterar todos os IPs detectados e exibi-los na tela.
    std::cout &lt;&lt; &quot;IP addresses for &quot; &lt;&lt; argv[1] &lt;&lt; &quot;:&quot; &lt;&lt; std::endl &lt;&lt; std::endl;
    for (auto result : results) {
        std::cout &lt;&lt; &quot;  &quot; &lt;&lt; result.endpoint().address().to_string() &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
<h2 id="quicksort-com-corrotinas"><a class="header" href="#quicksort-com-corrotinas">QuickSort com Corrotinas</a></h2>
<p>Referência: <a href="https://github.com/kprotty/zap/pull/8">Zap/Cpp benchmark</a> - An asynchronous runtime with a focus on performance and resource efficiency. </p>
<pre><code class="language-c++">#include &lt;algorithm&gt;
#include &lt;asio.hpp&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;vector&gt;

using namespace std::chrono;
using asio::awaitable;
using asio::co_spawn;
using asio::detached;

awaitable&lt;void&gt; quickSort(asio::io_context &amp;ctx,
                          std::vector&lt;int&gt;::iterator begin,
                          std::vector&lt;int&gt;::iterator end) {
  if (std::distance(begin, end) &lt;= 32) {
    // Use std::sort for small inputs
    std::sort(begin, end);
  } else {
    auto pivot = begin + std::distance(begin, end) - 1;
    auto i = std::partition(begin, pivot, [=](int x) { return x &lt;= *pivot; });
    std::swap(*i, *pivot);

    co_await quickSort(ctx, begin, i);
    co_await quickSort(ctx, i + 1, end);
  }
  co_return;
}

void shuffle(std::vector&lt;int&gt; &amp;arr) {
  std::mt19937 rng(std::random_device{}());
  std::shuffle(std::begin(arr), std::end(arr), rng);
}

int main() {
  std::vector&lt;int&gt; arr(10'000'000);

  std::cout &lt;&lt; &quot;filling&quot; &lt;&lt; std::endl;
  std::iota(std::begin(arr), std::end(arr), 0);

  std::cout &lt;&lt; &quot;shuffling&quot; &lt;&lt; std::endl;
  shuffle(arr);

  std::cout &lt;&lt; &quot;running&quot; &lt;&lt; std::endl;

  const int num_threads = std::thread::hardware_concurrency();
  asio::io_context ctx{num_threads};
  const auto start = high_resolution_clock::now();

  co_spawn(
      ctx,
      [&amp;]() -&gt; awaitable&lt;void&gt; {
        co_await quickSort(ctx, std::begin(arr), std::end(arr));
      },
      detached);

  // Run the io_context to process the posted tasks
  ctx.run();

  const auto elapsed =
      duration_cast&lt;milliseconds&gt;(high_resolution_clock::now() - start);
  std::cout &lt;&lt; &quot;took &quot; &lt;&lt; elapsed.count() &lt;&lt; &quot;ms&quot; &lt;&lt; std::endl;

  if (!is_sorted(std::begin(arr), std::end(arr))) {
    throw std::runtime_error(&quot;array not sorted&quot;);
  }
}
</code></pre>
<h2 id="servidor-tcp-com-wolfssl-base"><a class="header" href="#servidor-tcp-com-wolfssl-base">Servidor TCP com WolfSSL (base)</a></h2>
<p><strong>Nota:</strong> Apenas ilustrativo. Requer aprimoramento complementar!</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;boost/asio.hpp&gt;
#include &lt;wolfssl/ssl.h&gt;

namespace asio = boost::asio;
using asio::ip::tcp;

class wolfSSL_context
{
public:
  wolfSSL_context(asio::io_context&amp; io_context,
                  asio::ssl::context::method method)
    : context_(io_context, method)
  {
    context_.set_options(
      asio::ssl::context::default_workarounds
      | asio::ssl::context::no_sslv2
      | asio::ssl::context::single_dh_use);

    // Utilizar os certificados.
    context_.use_certificate_chain_file(&quot;server.crt&quot;);
    context_.use_private_key_file(&quot;server.key&quot;, asio::ssl::context::pem);
    context_.use_tmp_dh_file(&quot;dh2048.pem&quot;);
  }

  asio::ssl::context&amp; context()
  {
    return context_;
  }

private:
  asio::ssl::context context_;
};

class wolfSSL_stream
  : public asio::ssl::stream&lt;tcp::socket&gt;
{
public:
  wolfSSL_stream(asio::io_context&amp; io_context, wolfSSL_context&amp; context)
    : asio::ssl::stream&lt;tcp::socket&gt;(io_context, context.context())
  {
  }
};

class wolfSSL_server
{
public:
  wolfSSL_server(asio::io_context&amp; io_context,
                 unsigned short port)
    : acceptor_(io_context, tcp::endpoint(tcp::v4(), port)),
      context_(io_context, asio::ssl::context::tlsv12)
  {
    start_accept();
  }

private:
  void start_accept()
  {
    wolfSSL_stream new_stream(acceptor_.get_io_context(), context_);

    acceptor_.async_accept(new_stream.next_layer(),
                           std::bind(&amp;wolfSSL_server::handle_accept, this,
                                     std::placeholders::_1,
                                     std::move(new_stream)));
  }

  void handle_accept(const asio::error_code&amp; error,
                     wolfSSL_stream stream)
  {
    if (!error)
    {
      stream.handshake(asio::ssl::stream_base::server);

      // Executar o Handshake com SSL/TLS e ler os dados do cliente.
      // ...

      start_accept();
    }
  }

  tcp::acceptor acceptor_;
  wolfSSL_context context_;
};

int main()
{
  try
  {
    asio::io_context io_context;

    wolfSSL_server server(io_context, 443);

    io_context.run();
  }
  catch (std::exception&amp; e)
  {
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
  }

  return 0;
}
</code></pre>
<h2 id="noise-c-com-asio"><a class="header" href="#noise-c-com-asio">Noise-C com Asio</a></h2>
<p><strong>Cliente:</strong></p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;array&gt;
#include &lt;boost/asio.hpp&gt;
#include &lt;noise/protocol.h&gt;
#include &lt;noise/handshake.h&gt;

using boost::asio::ip::tcp;

int main(int argc, char *argv[]) {

    // Declara as chaves públicas estáticas local e remota
    std::array&lt;uint8_t, NOISE_PUBLIC_KEY_LEN&gt; local_static_public_key;
    local_static_public_key.fill(0x55);
    std::array&lt;uint8_t, NOISE_PUBLIC_KEY_LEN&gt; remote_static_public_key;
    remote_static_public_key.fill(0xAA);

    // Declara as chaves públicas efêmeras local e remota
    std::array&lt;uint8_t, NOISE_PUBLIC_KEY_LEN&gt; local_ephemeral_public_key;
    std::array&lt;uint8_t, NOISE_PUBLIC_KEY_LEN&gt; remote_ephemeral_public_key;

    // Declara as chaves privadas efêmeras local e remota
    std::array&lt;uint8_t, NOISE_PUBLIC_KEY_LEN&gt; local_ephemeral_private_key;
    std::array&lt;uint8_t, NOISE_PUBLIC_KEY_LEN&gt; remote_ephemeral_private_key;

    // Declara o estado da negociação de chave
    NoiseHandshakeState *state = 0;

    // Inicializa o estado da negociação de chave
    int result = noise_handshakestate_new_by_name(
        &amp;state, &quot;Noise_NN_25519_ChaChaPoly_BLAKE2s&quot;, 0);
    if (result != NOISE_ERROR_NONE) {
        std::cerr &lt;&lt; &quot;Error initializing handshake state&quot; &lt;&lt; std::endl;
        return 1;
    }

    // Define as chaves públicas estáticas local e remota
    noise_handshakestate_set_local_static_public_key(state, local_static_public_key.data(), local_static_public_key.size());
    noise_handshakestate_set_remote_static_public_key(state, remote_static_public_key.data(), remote_static_public_key.size());

    // Gera o par de chaves efêmeras local
    result = noise_handshakestate_generate_local_keypair(state, local_ephemeral_private_key.data(), local_ephemeral_private_key.size());
    if (result != NOISE_ERROR_NONE) {
        std::cerr &lt;&lt; &quot;Error generating local ephemeral key pair&quot; &lt;&lt; std::endl;
        return 1;
    }
    noise_handshakestate_get_local_public_key(state, local_ephemeral_public_key.data(), local_ephemeral_public_key.size());

    // Cria um objeto boost::asio::io_context
    boost::asio::io_context io_context;

    // Cria um objeto boost::asio::ip::tcp::socket
    tcp::socket socket(io_context);

    // Conecta ao servidor
    boost::asio::connect(socket, tcp::resolver(io_context).resolve({ &quot;localhost&quot;, &quot;1234&quot; }));

    // Envia a chave pública efêmera local ao servidor
    boost::asio::write(socket, boost::asio::buffer(local_ephemeral_public_key));

    // Recebe a chave pública efêmera remota do servidor
    boost::asio::read(socket, boost::asio::buffer(remote_ephemeral_public_key));
    noise_handshakestate_set_remote_ephemeral_public_key(state, remote_ephemeral_public_key.data(), remote_ephemeral_public_key.size());

    // Gera a chave privada efêmera remota
    result = noise_handshakestate_generate_remote_key(state, remote_ephemeral_private_key.data(), remote_ephemeral_private_key.size());
    if (result != NOISE_ERROR_NONE) {
        std::cerr &lt;&lt; &quot;Error generating remote ephemeral private key&quot; &lt;&lt; std::endl;
        return 1;
    }

    // Realiza a negociação de chave (handshake)
    size_t message_len;
    std::array&lt;uint8_t, MAX_HANDSHAKE_MESSAGE_LEN&gt; message;
    result = noise_handshakestate_start(state, message.data(), &amp;message_len);
    if (result != NOISE_ERROR_NONE) {
        std::cerr &lt;&lt; &quot;Error starting handshake&quot; &lt;&lt; std::endl;
        return 1;
    }
    // Envia a mensagem ao servidor
    boost::asio::write(socket, boost::asio::buffer(message, message_len));
    // Recebe a resposta do servidor
    boost::asio::read(socket, boost::asio::buffer(remote_ephemeral_public_key));
    result = noise_handshakestate_write_message(state, remote_ephemeral_public_key.data(), remote_ephemeral_public_key.size(), message.data(), &amp;message_len);
    if (result != NOISE_ERROR_NONE) {
        std::cerr &lt;&lt; &quot;Error writing handshake message&quot; &lt;&lt; std::endl;
        return 1;
    }
    // Envia a mensagem ao servidor
    boost::asio::write(socket, boost::asio::buffer(message, message_len));
    // Recebe a resposta do servidor
    boost::asio::read(socket, boost::asio::buffer(remote_ephemeral_public_key));
    result = noise_handshakestate_read_message(state, message.data(), message_len, remote_ephemeral_public_key.data(), &amp;remote_ephemeral_public_key.size());
  if (result != NOISE_ERROR_NONE) {
    std::cerr &lt;&lt; &quot;Error reading handshake message&quot; &lt;&lt; std::endl;
    return 1;
  }

  // Libera o estado do handshake
  noise_handshakestate_free(state);

  // Encerra socket
  socket.close();

  return 0;
}
</code></pre>
<p><strong>Servidor:</strong></p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;array&gt;
#include &lt;boost/asio.hpp&gt;
#include &lt;noise/protocol.h&gt;
#include &lt;noise/handshake.h&gt;

using boost::asio::ip::tcp;

int main(int argc, char *argv[]) {

    // Declara as chaves públicas estáticas local e remota
    std::array&lt;uint8_t, NOISE_PUBLIC_KEY_LEN&gt; local_static_public_key;
    local_static_public_key.fill(0x55);
    std::array&lt;uint8_t, NOISE_PUBLIC_KEY_LEN&gt; remote_static_public_key;
    remote_static_public_key.fill(0xAA);

    // Declara as chaves públicas efêmeras local e remota
    std::array&lt;uint8_t, NOISE_PUBLIC_KEY_LEN&gt; local_ephemeral_public_key;
    std::array&lt;uint8_t, NOISE_PUBLIC_KEY_LEN&gt; remote_ephemeral_public_key;

    // Declara as chaves privadas efêmeras local e remota
    std::array&lt;uint8_t, NOISE_PUBLIC_KEY_LEN&gt; local_ephemeral_private_key;
    std::array&lt;uint8_t, NOISE_PUBLIC_KEY_LEN&gt; remote_ephemeral_private_key;

    // Declara o estado da negociação de chave
    NoiseHandshakeState *state = 0;

    // Inicializa o estado da negociação de chave
    int result = noise_handshakestate_new_by_name(
        &amp;state, &quot;Noise_NN_25519_ChaChaPoly_BLAKE2s&quot;, 0);
    if (result != NOISE_ERROR_NONE) {
        std::cerr &lt;&lt; &quot;Error initializing handshake state&quot; &lt;&lt; std::endl;
        return 1;
    }

    // Define as chaves públicas estáticas local e remota
    noise_handshakestate_set_local_static_public_key(state, local_static_public_key.data(), local_static_public_key.size());
    noise_handshakestate_set_remote_static_public_key(state, remote_static_public_key.data(), remote_static_public_key.size());

    // Gera o par de chaves efêmeras local
    result = noise_handshakestate_generate_local_keypair(state, local_ephemeral_private_key.data(), local_ephemeral_private_key.size());
    if (result != NOISE_ERROR_NONE) {
        std::cerr &lt;&lt; &quot;Error generating local ephemeral key pair&quot; &lt;&lt; std::endl;
        return 1;
    }
    noise_handshakestate_get_local_public_key(state, local_ephemeral_public_key.data(), local_ephemeral_public_key.size());

    // Cria um objeto boost::asio::io_context
    boost::asio::io_context io_context;

    // Cria um objeto boost::asio::ip::tcp::acceptor
    tcp::acceptor acceptor(io_service, tcp::endpoint(tcp::v4(), 1234));

    // Aguarda uma conexão do cliente
    tcp::socket socket(io_service);
    acceptor.accept(socket);

    // Recebe a chave pública efêmera local do cliente
    boost::asio::read(socket, boost::asio::buffer(remote_ephemeral_public_key));
    noise_handshakestate_set_remote_ephemeral_public_key(state, remote_ephemeral_public_key.data(), remote_ephemeral_public_key.size());

    // Gera o par de chaves efêmeras local
    result = noise_handshakestate_generate_local_keypair(state, local_ephemeral_private_key.data(), local_ephemeral_private_key.size());
    if (result != NOISE_ERROR_NONE) {
        std::cerr &lt;&lt; &quot;Error generating local ephemeral private key&quot; &lt;&lt; std::endl;
        return 1;
    }
    noise_handshakestate_get_local_public_key(state, local_ephemeral_public_key.data(), local_ephemeral_public_key.size());

    // Envia a chave pública efêmera local ao cliente
    boost::asio::write(socket, boost::asio::buffer(local_ephemeral_public_key));

    // Realiza a negociação de chave (handshake)
    size_t message_len;
    std::array&lt;uint8_t, MAX_HANDSHAKE_MESSAGE_LEN&gt; message;

    // Recebe a primeira mensagem do cliente
    boost::asio::read(socket, boost::asio::buffer(message));
    result = noise_handshakestate_read_message(state, message.data(), message.size(), remote_ephemeral_public_key.data(), &amp;remote_ephemeral_public_key.size());
    if (result != NOISE_ERROR_NONE) {
        std::cerr &lt;&lt; &quot;Error to read first handshake message&quot; &lt;&lt; std::endl;
        return 1;
    }

    result = noise_handshakestate_write_message(state, remote_ephemeral_public_key.data(), remote_ephemeral_public_key.size(), message.data(), &amp;message_len);
    if (result != NOISE_ERROR_NONE) {
        std::cerr &lt;&lt; &quot;Error to write first handshake message&quot; &lt;&lt; std::endl;
        return 1;
    }
    // Envia a primeira mensagem ao cliente
    boost::asio::write(socket, boost::asio::buffer(message, message_len));
    // Recebe a segunda mensagem do cliente
    boost::asio::read(socket, boost::asio::buffer(message));
    result = noise_handshakestate_read_message(state, message.data(), message.size(), remote_ephemeral_public_key.data(), &amp;remote_ephemeral_public_key.size());
    if (result != NOISE_ERROR_NONE) {
        std::cerr &lt;&lt; &quot;Error to read second handshake message&quot; &lt;&lt; std::endl;
        return 1;
    }
    
    result = noise_handshakestate_write_message(state, remote_ephemeral_public_key.data(), remote_ephemeral_public_key.size(), message.data(), &amp;message_len);
    if (result != NOISE_ERROR_NONE) {
        std::cerr &lt;&lt; &quot;Error to write first handshake message&quot; &lt;&lt; std::endl;
        return 1;
    }
    // Envia a segunda mensagem ao cliente
    boost::asio::write(socket, boost::asio::buffer(message, message_len));

    // Gera a chave privada efêmera remota
    result = noise_handshakestate_generate_remote_key(state, remote_ephemeral_private_key.data(), remote_ephemeral_private_key.size());
    if (result != NOISE_ERROR_NONE) {
        std::cerr &lt;&lt; &quot;Error generating remote ephemeral private key&quot; &lt;&lt; std::endl;
        return 1;
    }


  // Libera o estado do handshake
  noise_handshakestate_free(state);

  // Encerra socket
  socket.close();

  return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conclusão-"><a class="header" href="#conclusão-">Conclusão 🎉</a></h1>
<p>Espero que tenha esclarecido o uso da programação de rede com <a href="https://think-async.com/Asio">Asio</a> para você. Definitivamente, este pequeno livro apenas introduz a idéia básica. Para melhorar sua habilidade de codificação, você precisa ler mais a <a href="https://think-async.com/Asio/boost_asio_1_24_0/doc/html/boost_asio.html">documentação</a> junto com o código-fonte e praticar mais. 👀</p>
<p>Bons estudos e divirta-se praticando! 😉</p>
<hr />
<h2 id="como-contribuir"><a class="header" href="#como-contribuir">Como contribuir</a></h2>
<p>Para contribuir, basta abrir uma issue no <a href="https://github.com/kassane/ebook-net-prog">repositório do projeto</a>, explicando como exatamente você poderia contribuir.
Exemplos e sugestões de possíveis contribuições incluem:</p>
<ul>
<li><strong>Revisão</strong>: Precisamos tanto de revisões técnicas quanto de português. Sinalize que você deseja ser um revisor abrindo uma issue falando do seu interesse!</li>
<li><strong>Escrita</strong>: Abra uma issue ou PR com um capítulo, seção ou parágrafo de exemplo em qualquer parte do livro, e explique por que ela é relevante.</li>
<li><strong>Infraestrutura</strong>: O livro atualmente está escrito totalmente em markdown. Sugestões e ajuda para melhorar a infraestrutura de leitura é bem vinda.</li>
<li><strong>Sugestões de conteúdo</strong>: Abra uma issue contando por que você acha que o novo conteúdo deveria estar presente no livro.</li>
</ul>
<h2 id="licença"><a class="header" href="#licença">Licença</a></h2>
<p>O material disponível diretamente neste repositório está sob <a href="cpp-asio/LICENSE">licença CC-0</a>.</p>
<h1 id="contribuintes"><a class="header" href="#contribuintes">Contribuinte(s)</a></h1>
<h3 id="meus-agradecimentos-são-para"><a class="header" href="#meus-agradecimentos-são-para">Meus agradecimentos são para:</a></h3>
<ul>
<li><a href="https://github.com/chriskohlhoff">Christopher M. Kohlhoff</a> - Autor do Asio</li>
<li><a href="https://github.com/NanXiao/boost-asio-network-programming-little-book">Nan Xiao</a> - Autor do projeto original (boost-asio network programming - little book)</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
